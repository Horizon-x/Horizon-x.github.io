<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ONESTONE Blogs</title>
  <icon>http://onexstone.online/icon.png</icon>
  <subtitle>Youth means limitless possibilities</subtitle>
  <link href="http://onexstone.online/atom.xml" rel="self"/>
  
  <link href="http://onexstone.online/"/>
  <updated>2021-09-26T02:30:35.032Z</updated>
  <id>http://onexstone.online/</id>
  
  <author>
    <name>ONESTONE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://onexstone.online/posts/4a17b156/"/>
    <id>http://onexstone.online/posts/4a17b156/</id>
    <published>2021-09-26T01:02:21.941Z</published>
    <updated>2021-09-26T02:30:35.032Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深入剖析volatile关键字</title>
    <link href="http://onexstone.online/posts/369cb3ec/"/>
    <id>http://onexstone.online/posts/369cb3ec/</id>
    <published>2021-09-25T09:29:28.000Z</published>
    <updated>2021-09-25T11:12:20.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><blockquote><p>关键字 volatile 可以说是 Java 提供的最轻量级的同步机制，但由于它并不容易被正确、完整地理解，因此在笔者查阅了相关资料后，觉得有必要深入剖析一下在 JVM 层面上，对 volatile 型变量都做了哪些支持。</p></blockquote><span id="more"></span><h3 id="2-测试环境"><a href="#2-测试环境" class="headerlink" title="2. 测试环境"></a>2. 测试环境</h3><pre><code>- JDK：    - java version &quot;1.8.0_202&quot;    - Java(TM) SE Runtime Environment (build 1.8.0_202-b08)    - Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)- OS：Windows 10- IDE：    - IntelliJ IDEA 2021.1.3 (Ultimate Edition)    - Eclipse IDE , Version: Oxygen.3a Release (4.7.3a)- HSDIS plug-in :    - [Windows Version](https://github.com/doexit/hsdis.dll)</code></pre><hr><h3 id="3-volatile-的定义"><a href="#3-volatile-的定义" class="headerlink" title="3. volatile 的定义"></a>3. volatile 的定义</h3><ul><li>Java 语言规范（第三版）中对 volatile 的定义如下：<blockquote><p>Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致性的更新，线程应该确保通过排他锁单独获得这个变量。</p></blockquote></li></ul><hr><h3 id="4-volatile-型变量的特性"><a href="#4-volatile-型变量的特性" class="headerlink" title="4. volatile 型变量的特性"></a>4. volatile 型变量的特性</h3><ul><li>JMM （Java Memory Model, Java 内存模型）中对 volatile 变量定义的特殊规则：<ul><li>要求在工作内存中，每次使用 volatile 变量之前都必须先从主内存刷新最新的值，用于保证能看到其他线程对 volatile 变量所做的修改。</li><li>要求在工作内存中，每次修改 volatile 变量后都必须立刻同步回主内存，用于保证其他线程可以看到自己对 volatile 变量所做的修改。</li><li>要求被 volatile 修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。</li></ul></li><li>因此，当一个变量被定义成 volatile 之后，它将具有以下两个特性：<ul><li>保证此变量对所有线程的可见性；</li><li>禁止指令重排序优化（尤其指变量赋值操作的顺序）</li></ul></li></ul><hr><h3 id="5-语义解释"><a href="#5-语义解释" class="headerlink" title="5. 语义解释"></a>5. 语义解释</h3><ul><li><p>线程的可见性：</p><blockquote><p>一般指当一条线程修改了这个变量的值，新值对其他线程来说是可以立即得知的。</p></blockquote></li><li><p>JVM 中对该语义的支持</p><ul><li><p>使用双锁检测（DCL）实现的单例模式进行讲解，Java 源代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Singleton &#123;    private volatile static Singleton instance;    public static Singleton getInstance() &#123;        if (instance &#x3D;&#x3D; null) &#123;            synchronized (Singleton.class) &#123;                if (instance &#x3D;&#x3D; null) &#123;                    instance &#x3D; new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;    public static void main(String[] args) &#123;        Singleton.getInstance();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>其中，对 instance 变量赋值的部分转成汇编代码（此处使用的是 HSDIS 插件，该插件的作用是让 HostSpot 的 -XX:PrintAssembly 指令调用它来把即时编译器动态生成的本地代码还原成汇编代码输出），如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">0x00000000032061dc: movabs $0xd5ec0c38,%rax   ;   &#123;oop(a &#39;java&#x2F;lang&#x2F;Class&#39; &#x3D; &#39;com&#x2F;xxx&#x2F;JVMTest&#x2F;Singleton&#39;)&#125;0x00000000032061e6: mov    0x20(%rsp),%rsi0x00000000032061eb: mov    %rsi,%r100x00000000032061ee: mov    %r10d,0x68(%rax)0x00000000032061f2: shr    $0x9,%rax0x00000000032061f6: movabs $0x120b4000,%rsi0x0000000003206200: movb   $0x0,(%rax,%rsi,1)0x0000000003206204: lock addl $0x0,(%rsp)     ;*putstatic instance                                            ; - com.xxx.JVMTest.Singleton::getInstance@24 (line 17)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>通过对比 volatile 添加前后的汇编代码可以发现，有 volatile 变量修饰的共享变量进行写操作的时候会多执行一个 “lock addl $0x0,(%rsp)” 操作，这个操作的作用相当于一个内存屏障。</p></li><li><p>通过查询 IA32 手册可知，lock 前缀的指令在多核处理器下会引发两件事情：</p><ul><li>将当前处理器缓存行的数据写回到系统内存；</li><li>该写入动作会使其他处理器或者内核中缓存了该内存地址的数据无效化。</li></ul></li><li><p>因此，通过这样一个空操作（addl $0x0,(%rsp)，把RSP寄存器的值加0），就可以让前面 volatile 变量的修改对其他处理器立即可见。同时，因为 lock 指令的本质是对 volatile 变量立即进行 “store” 和 “write” 操作，即该指令依赖于之前对 volatile 变量的其他操作，进而使得处理器不会对 lock 指令进行重排序到 volatile 其他指令之前，也就达到了“指令重排序无法越过内存屏障”的效果。</p></li></ul><hr><h3 id="6-理解误区"><a href="#6-理解误区" class="headerlink" title="6. 理解误区"></a>6. 理解误区</h3><ul><li><p><strong>基于 volatile 变量的运算在并发下是线程安全的。 (×)</strong></p></li><li><p>下面，笔者用一个 volatile 变量自增的例子来说明这个问题</p>  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class VolatileTest &#123;    public static volatile int count &#x3D; 0;    public static void increase() &#123;        count++;    &#125;    private static final int THREADS_COUNT &#x3D; 20;    public static void main(String[] args) &#123;        Thread[] threads &#x3D; new Thread[THREADS_COUNT];        for (int i &#x3D; 0; i &lt; THREADS_COUNT; i++) &#123;            threads[i] &#x3D; new Thread(new Runnable() &#123;                @Override                public void run() &#123;                    for (int i &#x3D; 0; i &lt; 100; i++) &#123;                        increase();                    &#125;                &#125;            &#125;);            threads[i].start();        &#125;        &#x2F;&#x2F; 等待所有累加线程都结束        while (Thread.activeCount() &gt; 1) &#123;            Thread.yield();        &#125;        System.out.println(count);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行演示<br><img src="https://oscimg.oschina.net/oscnet/up-847fae85f848d492abb003083a403ac0556.gif" alt="VolatileTest执行演示" loading="lazy"><em>VolatileTest执行演示</em></p></li><li><p>这段代码的作用是建立了 20 个线程，每个线程对 count 变量进行 100 次自增操作。理论上，在所有线程并发正确的情况下，最后输出的结果应该是 2000 。但通过多次的实际运行可以发现，每次输出的结果都不一样，甚至是一个小于 2000 的数字。</p></li><li><p>使用 javap 命令对 VolatileTest 进行反编译的代码如下：</p>  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void increase();    Code:    0: getstatic     #2                  &#x2F;&#x2F; Field count:I    3: iconst_1    4: iadd    5: putstatic     #2                  &#x2F;&#x2F; Field count:I    8: return    LineNumberTable:    line 15: 0    line 16: 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从字节码层面我们可以很容易的发现问题的所在，当 getstatic 指令把 count 的值取到操作栈顶时， volatile 关键字保证了 count 的值在此时是正确的，但在执行 iconst_1 、iadd 这些指令（非原子操作）的时候，其他线程可能已经把 count 的值改变了，而操作栈顶的值就变成了过期的数据，所以 putstatic 指令执行后就可能把较小的 count 值同步回主内存中。</p></li></ul><hr><h3 id="7-使用场景"><a href="#7-使用场景" class="headerlink" title="7. 使用场景"></a>7. 使用场景</h3><ul><li>通过上面的例子我们应该清楚，由于 volatile 变量只保证可见性，在不符合以下两条规则的运算场景中，我们依然需要通过加锁（使用 synchronized、java.util.concurrent 中的锁或原子类）来保证原子性：<ul><li>运算结果并不依赖变量的当前值（无后效性），或者能够确保只有单一的线程修改变量的值；</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul></li></ul><hr><h3 id="8-参考文献"><a href="#8-参考文献" class="headerlink" title="8. 参考文献"></a>8. 参考文献</h3><pre><code>1. 方腾飞, 魏鹏, 程晓明．Java并发编程的艺术 [M]. 北京：机械工业出版社，2015：8-11.2. 周志明．深入理解Java虚拟机: JVM高级特性与最佳实践（3 版）[M]. 北京：机械工业出版社，2019：444-450.</code></pre>]]></content>
    
    
    <summary type="html">Java 并发底层原理的支持</summary>
    
    
    
    <category term="Java" scheme="http://onexstone.online/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://onexstone.online/tags/JVM/"/>
    
  </entry>
  
</feed>
