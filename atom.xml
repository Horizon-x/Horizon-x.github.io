<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ONESTONE Blogs</title>
  <icon>https://www.onexstone.online/icon.png</icon>
  <subtitle>Youth means limitless possibilities</subtitle>
  <link href="https://www.onexstone.online/atom.xml" rel="self"/>
  
  <link href="https://www.onexstone.online/"/>
  <updated>2021-09-26T07:24:03.710Z</updated>
  <id>https://www.onexstone.online/</id>
  
  <author>
    <name>ONESTONE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java项目中的ClassPath的前世今生</title>
    <link href="https://www.onexstone.online/posts/ef0e997a/"/>
    <id>https://www.onexstone.online/posts/ef0e997a/</id>
    <published>2021-09-26T07:06:39.000Z</published>
    <updated>2021-09-26T07:24:03.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java项目的classpath是什么？"><a href="#1-Java项目的classpath是什么？" class="headerlink" title="1. Java项目的classpath是什么？"></a>1. Java项目的classpath是什么？</h3><ul><li> 定义：<code>classpath</code> 就是 <code>class</code> 的 <code>path</code> ，直译就是指类文件 ( <code>*.class</code> ) 的路径。</li></ul><span id="more"></span><h3 id="2-用途"><a href="#2-用途" class="headerlink" title="2.  用途"></a>2.  用途</h3><ul><li><code>classpath</code> 的作用就是通知 <code>JVM</code> (Java虚拟机) 用户类的存放路径。当运行我们的 <code>Java</code> 程序时，<code>JVM</code> 会按照 <code>classpath</code> 指定的文件中去查找相应类的 <code>*.class</code> 文件。</li><li>我们在指定一些 配置/资源 文件的时候也会使用到 <code>classpath</code>。例如，在 <code>web.xml</code> 中指定 <code>springMVC</code> 的配置文件，如下图，<code>classpath: entry/dev/spring-mvc.xml</code>。<br><img src="https://oscimg.oschina.net/oscnet/up-19a35a6a2db5669afaca626ba53a7edcd3d.png" alt="springMVC 的配置文件" loading="lazy"><em>springMVC 的配置文件</em></li><li>再比如，当我们把 <code>*Mapper.xml</code> 文件放在了 <code>src/main/java/../mapping/</code> 文件夹下时，在 <code>mybatis</code> 的配置文件中配置其位置。<br><img src="https://oscimg.oschina.net/oscnet/up-f0f15e3c6a331d3bc3e21ad3cccde1d3393.png" alt="Mybits的配置文件" loading="lazy"><em>Mybits的配置文件</em></li><li>很显然，上面这 2 个 <code>classpath</code> 的配置，是为了告诉配置文件，去哪里寻找我们要指定的配置文件。</li></ul><h3 id="3-解释"><a href="#3-解释" class="headerlink" title="3.  解释"></a>3.  解释</h3><p>要想弄清楚为什么是上面这样写的，我们就要来看看项目运行时（或者是发布后）的目录结构了，首先：</p><ul><li>以一个普通的 <code>JavaWeb</code> 项目为例，根据 <code>maven</code> 的约定，一般我们的项目结构就像下面这样。<br><img src="https://oscimg.oschina.net/oscnet/up-0ab81070cc2a3d5191957d0d5d755d8a068.png" alt="JavaWeb项目的目录结构" loading="lazy"><em>JavaWeb项目的目录结构</em></li><li>我们使用 IDEA 对项目进行打包，一种是 <code>war</code> 包，一种是 <code>explorer</code> 的文件夹， <code>war</code> 包解压后就是 <code>explorer</code> 了。我们来对解压后的目录结构进行分析。</li><li>经过对比，我们要注意到，开发时期的项目里，<code>src/main/</code> 下面的 <code>java</code> 和 <code>resources</code> 文件夹都被(编译)打包到了生产包的 <code>WEB-INF/classes/</code> 目录下；而原来 <code>WEB-INF</code> 下面的 <code>views</code> 和 <code>web.xml</code> 则仍然还是在 <code>WEB-INF</code> 下面。同时由 <code>maven</code> 引入的依赖都被放入到了 <code>WEB-INF/lib/</code> 下面。最后，编译后的 <code>class</code> 文件和资源文件都放在了 <code>classes</code> 目录下。<br><img src="https://oscimg.oschina.net/oscnet/up-1e219408177c6b48092fcdc6073a67ec8cf.png" alt="JavaWeb项目打包后的目录结构" loading="lazy"><em>JavaWeb项目打包后的目录结构</em></li></ul><h3 id="4-classpath-的真面目"><a href="#4-classpath-的真面目" class="headerlink" title="4.  classpath 的真面目"></a>4.  <code>classpath</code> 的真面目</h3><ul><li>在编译打包后的项目中，根目录是 <code>META-INF</code> 和 <code>WEB-INF</code> 。这个时候，我们可以看到 <code>classes</code> 这个文件夹，它就是我们要找的 <code>classpath</code>。</li><li>在第 1 个例子里，<code>classpath:entry/dev/spring-mvc.xml</code> 中， <code>classpath</code> 就是指 <code>WEB-INF/classes/</code> 这个目录的路径。需要声明的一点是，使用 <code>classpath</code> : 这种前缀，就只能代表一个文件。</li><li>在第 2 个例子里，<code>classpath*:**/mapper/mapping/*Mapper.xml</code>，使用 <code>classpath*</code> : 这种前缀，则可以代表多个匹配的文件；<code>**/mapper/mapping/*Mapper.xml</code> ，双星号 <code>**</code> 表示在任意目录下，也就是说在 <code>WEB-INF/classes/</code> 下任意层的目录，只要符合后面的文件路径，都会被作为资源文件找到。</li></ul><h3 id="5-如何获取项目类编译后的路径"><a href="#5-如何获取项目类编译后的路径" class="headerlink" title="5.  如何获取项目类编译后的路径"></a>5.  如何获取项目类编译后的路径</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">String path &#x3D; 类名.class.getClassLoader().getResource(&quot;&quot;).getPath();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.  总结"></a>6.  总结</h3><ul><li>  首先 <code>classpath</code> 是指 <code>WEB-INF</code> 文件夹下的 <code>classes</code> 目录。</li><li>解释 <code>classes</code> 含义：<ul><li>  存放各种资源配置文件 <code>init.properties、log4j.properties、struts.xml</code>；</li><li>  存放模板文件 <code>actionerror.ftl</code>；</li><li>  存放 <code>class</code> 文件，对应的是项目开发时 <code>src</code> 目录中 <code>Java</code> 源码的编译文件；</li></ul></li><li>  本质：<strong>这是一个定位资源的入口。</strong></li></ul><hr>]]></content>
    
    
    <summary type="html">结合项目案例分析Java项目中的ClassPath的作用</summary>
    
    
    
    <category term="Java" scheme="https://www.onexstone.online/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.onexstone.online/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>快速搭建一个简易的SpringBoot项目</title>
    <link href="https://www.onexstone.online/posts/78dbede3/"/>
    <id>https://www.onexstone.online/posts/78dbede3/</id>
    <published>2021-09-26T06:37:20.000Z</published>
    <updated>2021-09-26T07:08:01.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-本文将手把手教大家搭建一个简易但完整的SpringBoot项目。"><a href="#1-本文将手把手教大家搭建一个简易但完整的SpringBoot项目。" class="headerlink" title="1. 本文将手把手教大家搭建一个简易但完整的SpringBoot项目。"></a>1. 本文将手把手教大家搭建一个简易但完整的SpringBoot项目。</h3><span id="more"></span><h3 id="2-搭建环境："><a href="#2-搭建环境：" class="headerlink" title="2. 搭建环境："></a>2. 搭建环境：</h3><pre><code>- JDK：    - java version &quot;1.8.0_202&quot;    - Java(TM) SE Runtime Environment (build 1.8.0_202-b08)    - Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)- OS：Windows 10- IDE：IntelliJ IDEA 2021.1.3 (Ultimate Edition)</code></pre><h3 id="3-初始化-SpringBoot-项目"><a href="#3-初始化-SpringBoot-项目" class="headerlink" title="3. 初始化 SpringBoot 项目"></a>3. 初始化 <code>SpringBoot</code> 项目</h3><p>首先，我们先使用 <code>Spring Initializr</code> 初始化一个 <code>SpringBoot</code> 项目。</p><ul><li><p>3.1 打开 <code>IDEA</code> 的引导页面，选择 <code>New Project</code> 按钮。<br><img src="https://oscimg.oschina.net/oscnet/up-19480791ef100df655561f1499e95acc969.png" alt="IDEA引导页" loading="lazy"><em>图一 IDEA 引导页</em></p></li><li><p>或者进入 <code>IDEA</code> 后点击上方菜单栏，依次选择 <code>File</code> &gt; <code>New</code> 菜单下选择 <code>Project</code> 菜单栏。</p></li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-b1b51448fa34eaaf26d1a88e84ab91b7163.png" alt="菜单启动页" loading="lazy"><em>图二 菜单启动页</em></p><ul><li>3.2 此时，将会打开 <code>Spring Initializr</code> 项目向导的第一页，你会发现这个页面上有很多输入域与Maven pom.xml 文件中的信息是一致的，实际上，Tpye 输入域中选择 Maven ，就应该明白这些输入域的用途所在。如果想使用与 <a href="https://start.spring.io/">https://start.spring.io</a> 不同的 <code>Spring Initializr</code> ，就可以选择 <code>Server URL</code> 项右侧的设置图标，在弹出的文本框中输入想要使用的 <code>Spring Initializr</code> 的基础 <code>URL</code>。一般选择默认的官方网站即可。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-db18bd32f1c6fdad3ffe97ce04d51548936.png" alt="SpringInitializr引导页1" loading="lazy"><em>图三 SpringInitializr 引导页1</em></p><p><img src="https://oscimg.oschina.net/oscnet/up-01a3f9e0b03eead2f75ada03e9105a9609f.png" alt="SpringInitializr引导页2" loading="lazy"><em>图四 修改 Server URL 图</em></p><ul><li>3.3 在填写完必要的项目信息后，点击 Next 按钮将会进入到项目依赖引导页，其中左侧可以看到，依赖是按照目的分类来组织的，选中某个分类，就会显示出该分类下的全部的可选项。按照你的项目需求选择合适的依赖组件，选中的组件会依次显示在右下角的方框中。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-683ef49348f15b5424369871e5c907965a9.png" alt="SpringInitializr依赖页" loading="lazy"><em>图五 SpringInitializr 依赖页</em></p><ul><li>3.4 最后，点击 Finish 按钮，项目将会创建并加载到 IDEA 的工作空间，其中SpringBoot初始化生成的项目目录结构如图七所示。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-c314be5533bd6aee9d9de09906426c48eb8.png" alt="SpringBoot项目启动页" loading="lazy"><em>图六 SpringBoot 项目启动页</em></p><p><img src="https://oscimg.oschina.net/oscnet/up-f2fec315db9c5471d28755b52099766a7d1.png" alt="SpringBoot初始化生成的项目目录结构" loading="lazy"><em>图七 SpringBoot 初始化生成的目录结构</em></p><hr><h3 id="4-项目测试"><a href="#4-项目测试" class="headerlink" title="4. 项目测试"></a>4. 项目测试</h3><p>既然项目已经自动生成好了，那我们接下来当然是要测试一下项目是否真的能正常运行啦。</p><ul><li>4.1 首先，我们先新建一个包（<code>com.horizon.demo</code>），然后在该包下新建一个控制器类 <code>HomeController</code>，用来处理 <code>Web</code> 请求。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-2217fb1a8a48786a3f11b18f6345e6cb9ba.png" alt="homeController" loading="lazy"><em>图八 homeController 类</em></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Controllerpublic class HomeController &#123;    &#x2F;&#x2F;一个简单的controller，返回名为&quot;home&quot;的逻辑视图名    @GetMapping(&quot;&#x2F;&quot;)    public String home() &#123;        return &quot;home&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>4.2 接下来要定义一个名为 <code>home</code> 的视图，以完成整个 <code>web</code> 请求。为了让主页尽可能简单，除了欢迎用户访问站点之外，它不会做其他的任何事。唯一需要注意的一行代码是用于展现 <code>Home</code> 的 <code>&lt;img&gt;</code> 标签，它使用了 <code>Thymeleaf</code> 的 <code>th:src</code> 属性和 <code>@&#123;...&#125;</code> 表达式，以便于引用相对于上下文路径的图片。</li></ul><blockquote><p>注：图片是使用相对于上下文的 <code>&quot;/images/home.jpg&quot;</code> 路径来进行引用的。回忆一下我们的项目结构，像图片这样的静态资源是放到 <code>&quot;/src/main/resources&quot;</code> 文件夹中的。这意味着，在该项目中，<code>home</code> 图片必须要位于 <code>&quot;/src/main/resources/static/images/home.jpg&quot;</code> 。</p></blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-7cf103837957a293c210d1fd0132fcc939f.png" alt="homePage页面" loading="lazy"><em>图九 homePage 页面</em></p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;        xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Horizon-Home&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;Welcome to...&lt;&#x2F;h1&gt;    &lt;h3&gt;This is the Horizon‘s Home.&lt;&#x2F;h3&gt;    &lt;img th:src&#x3D;&quot;@&#123;&#x2F;images&#x2F;home.jpg&#125;&quot;&#x2F;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>4.3 目前，我们已经有了一个处理主页请求的控制器并且有了渲染主页的模板，那我们基本就可以启动应用来看一下它的效果了。我们在 <code>/src/test/java/com/horizon/demo</code> 包下新建一个 <code>HomeControllerTest </code> 的测试类。</li></ul><blockquote><p>通过 <code>testHomePage()</code> 方法，我们定义了针对主页想要执行的测试。它首先使用 <code>MockMvc</code> 对象对 <code>&quot;/&quot;</code> （根路径）发起 <code>HTTP GET</code> 请求。对于这个请求，我们设置了如下的预期：<br>    - 响应应该具备 <code>HTTP 200 (OK)</code> 状态;<br>    - 视图的逻辑名称应该是 <code>home</code>;<br>    - 渲染后的视图应该包含文本 <code>&quot;Welcome to...&quot;</code>。</p></blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-11de89919acb44eb25c538be34d5f3dffec.png" alt="HomeControllerTest.png" loading="lazy"><em>图十 HomeControllerTest 类</em></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RunWith(SpringRunner.class)@WebMvcTest(HomeController.class) &#x2F;&#x2F;针对 HomeController 的 Web 测试public class HomeControllerTest &#123;    @Autowired &#x2F;&#x2F;自动注入 MockMvc 类    private MockMvc mockmvc;    @Test    public void testHomePage () throws Exception &#123;        mockmvc.perform(get(&quot;&#x2F;&quot;)) &#x2F;&#x2F;发起对路径为 “&#x2F;” 的 GET 请求                .andExpect(status().isOk()) &#x2F;&#x2F;期望得到 HTTP 200 的响应状态码                .andExpect(view().name(&quot;home&quot;))&#x2F;&#x2F;期望得到 home 视图                .andExpect(content().string(                        containsString(&quot;Welcome to...&quot;)));&#x2F;&#x2F;期望页面内容包含 &quot;Welcome to...&quot;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>4.4 如果在 MockMvc 对象发送请求之后，这些期望有不满足的话，那么这个测试会失败。但是，我们的控制器和模板引擎在编写的时候都满足了这些预期，所以测试应该能够通过，并且带有成功的图标 —— 至少能够看到一些绿色的背景，表明测试通过了。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-4c1e79b88d50873b5c8994fb54f60fa1047.gif" alt="testHomeControllerSuccess" loading="lazy"><em>图十一 测试 HomeController</em></p><ul><li>4.5 尽管测试已经通过了，但是如果能够在浏览器中看到结果那会更有成就感，毕竟这才是我们编写这个项目的最终目的。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-a2252d1b86b561a8bca5b16d7c6c73abc8b.gif" alt="testHomePageSuccess" loading="lazy"><em>图十二 测试 HomePage</em></p><ul><li>4.6 最终的项目结构如下图所示。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-fab1d1bc3043ad76ea211c97f136c55bdad.png" alt="testHomePageSuccess" loading="lazy"><em>图十三 完整的项目目录结构</em></p><hr><h3 id="5-测试过程中遇到的问题"><a href="#5-测试过程中遇到的问题" class="headerlink" title="5. 测试过程中遇到的问题"></a>5. 测试过程中遇到的问题</h3><ul><li><p>出现 <code>Spring Boot——[java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration]</code><br>  <img src="https://oscimg.oschina.net/oscnet/up-cd604a634586a078a5c66b1f5836dee7138.png" alt="HomeControllerFailed" loading="lazy"><em>图十四 HomeController 测试失败堆栈信息图</em></p></li><li><p>问题分析：<br>  Spring Boot的启动类没在根目录下。由于新建的 <code>com.horizon.demo</code> 包前缀和 <code>com.horizon.xxx</code> 的相同，导致生成的 <code>SpringBootDemoApplication</code> 启动类不再在项目的根目录 <code>/src/main/java/com/horizon</code>下，使得 <code>SpringBoot</code> 找不到主类，也就无法成功初始化 <code>Spring</code> 应用上下文。 </p></li><li><p>解决方案：</p><ul><li>方案一：<code>Class</code><br>  在根目录下写一个 <code>SpringBoot</code> 的启动类。</li><li>方案二：注解<br>  在类上加上下面任意一种注解。      <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@SpringBootTest(classes &#x3D; Application.class)或者@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes &#x3D; &#123;JPAConfig.class&#125;)或者@RunWith(SpringRunner.class)@ContextConfiguration(classes &#x3D; &#123;JPAConfig.class&#125;)或者@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value&#x3D;&#123;&quot;myJPAConfig.xml&quot;&#125;)或者@RunWith(SpringRunner.class)@ContextConfiguration(value&#x3D;&#123;&quot;myJPAConfig.xml&quot;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><hr><h3 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h3><ol><li>Craig Walls．Spring实战 [M]. 北京：人民邮电出版社，2020：1-26.</li></ol>]]></content>
    
    
    <summary type="html">保姆式教程，Queck Start SpringBoot Project</summary>
    
    
    
    <category term="Spring" scheme="https://www.onexstone.online/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://www.onexstone.online/tags/Java/"/>
    
    <category term="SpringBoot" scheme="https://www.onexstone.online/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>初尝Java的语法糖</title>
    <link href="https://www.onexstone.online/posts/d2e8c2c4/"/>
    <id>https://www.onexstone.online/posts/d2e8c2c4/</id>
    <published>2021-09-26T06:28:44.000Z</published>
    <updated>2021-09-26T06:33:21.506Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是语法糖？"><a href="#1-什么是语法糖？" class="headerlink" title="1. 什么是语法糖？"></a>1. 什么是语法糖？</h3><blockquote><ul><li>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</li><li>需要声明的是 “语法糖” 这个词绝非贬义词，它可以给我们带来方便，是一种便捷的写法，编译器会帮我们做转换；而且可以提高开发编码的效率，在性能上也不会带来损失。</li></ul></blockquote><span id="more"></span><h3 id="2-Java-中的语法糖体现在哪？"><a href="#2-Java-中的语法糖体现在哪？" class="headerlink" title="2. Java 中的语法糖体现在哪？"></a>2. Java 中的语法糖体现在哪？</h3><ul><li>前面提到过，语法糖的存在主要是方便开发人员使用。但其实，<code>Java</code> 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</li><li>说到编译，大家肯定都知道，<code>Java</code> 语言中，<code>javac</code> 命令可以将后缀名为 <code>.java</code> 的源文件编译为后缀名为 <code>.class</code> 的可以运行于 <code>Java</code> 虚拟机的字节码。</li><li>如果你去看 <code>com.sun.tools.javac.main.JavaCompiler</code> 的源码，你会发现在 <code>compile()</code> 中有一个步骤就是调用 <code>desugar()</code> ，这个方法就是负责解语法糖的实现。</li><li>在 <code>Java</code> 中,目前存在的语法糖包含 <code>数字字面量、条件编译、断言、Switch语句与枚举及字符串结合、可变参数、自动装箱/拆箱、枚举、内部类、泛型擦除、增强for循环、lambda表达式、try-with-resources语句</code> 等等。</li></ul><h3 id="3-环境"><a href="#3-环境" class="headerlink" title="3. 环境"></a>3. 环境</h3><pre><code>- JDK：    - java version &quot;1.8.0_202&quot;    - Java(TM) SE Runtime Environment (build 1.8.0_202-b08)    - Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)- OS：Windows 10</code></pre><h3 id="4-反编译工具"><a href="#4-反编译工具" class="headerlink" title="4. 反编译工具"></a>4. 反编译工具</h3><ul><li>关于反编译工具, 其实在 <code>JDK</code> 中自带了一个 <code>javap</code> 命令, 但是日常中很少会用到 <code>javap</code> , 所以这次我打算借助另一个反编译工具 <code>CFR</code> 来分析 <code>Java</code> 中的语法糖, 这里我下载的是最新的 <a href="https://github.com/leibnitz27/cfr">cfr_0_151.jar</a>。</li></ul><h3 id="5-语法糖解析"><a href="#5-语法糖解析" class="headerlink" title="5. 语法糖解析"></a>5. 语法糖解析</h3><h4 id="1-字符串拼接"><a href="#1-字符串拼接" class="headerlink" title="1. 字符串拼接"></a>1. 字符串拼接</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;*** 字符串拼接* option: --stringbuilder false*&#x2F;public void stringBuilderTest(int end) &#123;    char[] foo &#x3D; new char[]&#123;&#39;@&#39;, &#39;a&#39;, &#39;*&#39;&#125;;    char ch;    int x &#x3D; 0;    while ((ch &#x3D; foo[++x]) !&#x3D; &#39;*&#39;) &#123;        System.out.println(&quot;&quot; + x + &quot;: &quot; + ch);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CRF 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr_0_132.jar CFRDecompilerDemo.class --stringbuilder false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;* * Decompiled with CFR 0.151. *&#x2F;public void stringBuilderTest() &#123;    char ch;    char[] foo &#x3D; new char[]&#123;&#39;@&#39;, &#39;a&#39;, &#39;*&#39;&#125;;    int x &#x3D; 0;    while ((ch &#x3D; foo[++x]) !&#x3D; &#39;*&#39;) &#123;        System.out.println(new StringBuilder().append(x).append(&quot;: &quot;).append(ch).toString());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 从反编译后的代码中能看出, 当我们使用 `+` 号进行字符串拼接操作时, 编译时会自动创建一个 `StringBuilder` 对象。所以在循环中拼接字符串时, 应避免使用 `+` 号操作, 否则每次循环都会创建一个 `StringBuilder` 对象再回收, 造成较大的开销。</code></pre><hr><h4 id="2-条件编译"><a href="#2-条件编译" class="headerlink" title="2. 条件编译"></a>2. 条件编译</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 条件编译 * option: 不需要参数 *&#x2F;public void ifCompilerTest() &#123;    if(false) &#123;        System.out.println(&quot;false if&quot;);    &#125;else &#123;        System.out.println(&quot;true else&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar ifCompilerTest.class<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void ifCompilerTest() &#123;    System.out.println(&quot;true else&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>- 分析：&gt;  - `javac` 编译器在编译时期的解语法糖阶段, 会将条件分支不成立的代码进行消除。</code></pre><hr><h4 id="3-断言"><a href="#3-断言" class="headerlink" title="3. 断言"></a>3. 断言</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 断言, JDK1.4开始支持 * option: --sugarasserts false *&#x2F;public void assertTest(String s) &#123;    assert (!s.equals(&quot;Fred&quot;));    System.out.println(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar assertTest.class --sugarasserts false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void assertTest(String s) &#123;    if (!$assertionsDisabled &amp;&amp; s.equals(&quot;Fred&quot;)) &#123;        throw new AssertionError();    &#125;    System.out.println(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt;  - 我们可以发现其实断言的底层实现就是 `if` 判断语句，当断言结果为 `true` 时, 程序继续正常执行, 当断言结果为 `false` 时, 则抛出 `AssertionError` 异常来打断程序的执行。&gt; - 同时，我们还可以看到 `javac` 编译器还添加了一个新的变量 `$assertionsDisabled`，回想一下我们想让虚拟机启用断言功能的时候，命令行指令为 ```java -ea xxx.java```。但为什么一定要加上 `-enableassertions (简写：-ea)` 参数呢？其实现在的你应该清楚了，就是想要告诉虚拟机把 `$assertionsDisabled` 字段的值设置成 `false`。</code></pre><hr><h4 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4. 枚举"></a>4. 枚举</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 枚举, JDK1.5开始支持 * option: --sugarenums false *&#x2F;public enum EnumTest &#123;    FOO, BAR, BAP&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar EnumsTest.class --sugarenums false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final class EnumTestextends Enum&lt;EnumTest&gt; &#123;    public static final &#x2F;* enum *&#x2F; EnumTest FOO &#x3D; new EnumTest(&quot;FOO&quot;, 0);    public static final &#x2F;* enum *&#x2F; EnumTest BAR &#x3D; new EnumTest(&quot;BAR&quot;, 1);    public static final &#x2F;* enum *&#x2F; EnumTest BAP &#x3D; new EnumTest(&quot;BAP&quot;, 2);    private static final &#x2F;* synthetic *&#x2F; EnumTest[] ENUM$VALUES;    static &#123;        ENUM$VALUES &#x3D; new EnumTest[]&#123;FOO, BAR, BAP&#125;;    &#125;    private EnumTest(String string, int n) &#123;        super(string, n);    &#125;    public static EnumTest[] values() &#123;        EnumTest[] enumTestArray &#x3D; ENUM$VALUES;        int n &#x3D; enumTestArray.length;        EnumTest[] enumTestArray2 &#x3D; new EnumTest[n];        System.arraycopy(ENUM$VALUES, 0, enumTestArray2, 0, n);        return enumTestArray2;    &#125;    public static EnumTest valueOf(String string) &#123;        return Enum.valueOf(EnumTest.class, string);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 当我们自定义一个枚举类型时, 编译器会自动创建一个被 `final` 修饰的枚举类来继承 `Enum` 类, 所以自定义的枚举类型是 **无法继承和被继承的**。当枚举类初始化时, 枚举字段引用该枚举类的一个静态常量对象, 并且所有的枚举字段都用常量数组 `$VALUES` 来存储。`values()` 方法内则调了用 `System.arraycopy` 方法, 参照 `$VALUES` 数组对象复制一个新的数组, 新数组会有所有的枚举字段。&gt; - 注意，在定义的枚举常量后都跟着一个数字，至于他是干嘛用的，等看完下一个语法糖后你就应该知道了。</code></pre><hr><h4 id="5-枚举与-Switch-语句"><a href="#5-枚举与-Switch-语句" class="headerlink" title="5. 枚举与 Switch 语句"></a>5. 枚举与 Switch 语句</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 枚举与Switch语句 * option: --decodeenumswitch false *&#x2F;public int switchEnumTest(EnumTest e) &#123;    switch (e) &#123;        case FOO:            return 1;        case BAP:            return 2;    &#125;    return 0;&#125;&#x2F;** * 枚举, JDK1.5开始支持 * option: --sugarenums false *&#x2F;public enum EnumTest &#123;    FOO,    BAR,    BAP&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar switchEnumTest.class --decodeenumswitch false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int switchEnumTest(EnumTest e) &#123;    switch (StringBuilderTest.$SWITCH_TABLE$com$xxx$SyntacticSugar$switchEnumTest$EnumTest()[e.ordinal()]) &#123;        case 1: &#123;            return 1;        &#125;        case 3: &#123;            return 2;        &#125;    &#125;    return 0;&#125;static &#x2F;* synthetic *&#x2F; int[] $SWITCH_TABLE$com$xxx$SyntacticSugar$switchEnumTest$EnumTest() &#123;    if ($SWITCH_TABLE$com$xxx$SyntacticSugar$switchEnumTest$EnumTest !&#x3D; null) &#123;        return $SWITCH_TABLE$com$xxx$SyntacticSugar$switchEnumTest$EnumTest;    &#125;    int[] nArray &#x3D; new int[EnumTest.values().length];    try &#123;        nArray[EnumTest.BAP.ordinal()] &#x3D; 3;    &#125;    catch (NoSuchFieldError noSuchFieldError) &#123;&#125;    try &#123;        nArray[EnumTest.BAR.ordinal()] &#x3D; 2;    &#125;    catch (NoSuchFieldError noSuchFieldError) &#123;&#125;    try &#123;        nArray[EnumTest.FOO.ordinal()] &#x3D; 1;    &#125;    catch (NoSuchFieldError noSuchFieldError) &#123;&#125;    $SWITCH_TABLE$com$xxx$SyntacticSugar$switchEnumTest$EnumTest &#x3D; nArray;    return nArray;&#125;public static enum EnumTest &#123;    FOO,    BAR,    BAP;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - `switch` 支持枚举是通过调用枚举类默认继承的父类 `Enum` 中的 `ordinal()` 方法来实现的, 这个方法会返回枚举常量的序数。&gt; - 而这个枚举常量的序数又是从哪来的呢？通过对比上一小节的 `EnumTest` 源码和反编译后的代码我们可以看到，这个数字其实就是编译器在声明一个枚举常量的时候，按照我们声明枚举元素的顺序加的一个序数。在实现 `switch` 语句的时候首先会给枚举元素“赋值”，所谓的“赋值”就是新建一个 int 数组，然后按照枚举元素的序号，在数组的对应位置上赋上一个 `int` 值，方便后续 `switch` 分支的匹配。这也解释了反编译后的源码中为什么 `switch` 分支的匹配条件从枚举元素名称，变成了对应枚举元素在 `nArray` 数组上的值。&gt; - 但为什么要多此一举去改变它们呢？其实 `Java` 规定了 `switch` 语句中的变量类型只能是： `byte` 、`short` 、`int` 或者 `char`。但从 `Java SE 7` 开始，`switch` 支持字符串 `String` 类型了，同时 `case` 标签必须为字符串常量或字面量。所以在 `Java SE 7` 以前的 `Java` 版本中若想实现 `swich` 语句用 `String` 类型的字符串作为条件，就得使用枚举类型来作为桥梁。</code></pre><hr><h4 id="6-字符串与-Switch-语句"><a href="#6-字符串与-Switch-语句" class="headerlink" title="6. 字符串与 Switch 语句"></a>6. 字符串与 Switch 语句</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**  * 字符串与Switch语句 * option: --decodestringswitch false *&#x2F;public int switchStringTest(String s) &#123;    switch (s) &#123;        default:            System.out.println(&quot;Test&quot;);            break;        case &quot;BB&quot;:  &#x2F;&#x2F; BB and Aa have the same hashcode.            return 12;        case &quot;Aa&quot;:        case &quot;FRED&quot;:            return 13;    &#125;    System.out.println(&quot;Here&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar switchStringTest.class --decodestringswitch false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;* * Enabled aggressive block sorting *&#x2F;public int switchStringTest(String s) &#123;    String string &#x3D; s;    switch (string.hashCode()) &#123;        case 2112: &#123;            if (string.equals(&quot;BB&quot;)) return 12;            if (string.equals(&quot;Aa&quot;)) return 13;            break;        &#125;        case 2166379: &#123;            if (string.equals(&quot;FRED&quot;)) return 13;        &#125;    &#125;    System.out.println(&quot;Test&quot;);    System.out.println(&quot;Here&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - `switch` 支持字符串是通过 `hashCode()` 和 `equals()` 方法来实现的, 先通过 `hashCode()` 返回的哈希值进行 `switch`, 然后通过`equals()` 方法比较进行安全检查, 调用 `equals()` 是为了防止可能发生的哈希碰撞。&gt; - **小总结：综合前三小节，（另外补充一点 switch 支持 char 类型是通过比较它们的  ascii 码来实现的，同时 ascii 码是整型。）所以  switch  其实只支持一种数据类型, 也就是整型, 其他诸如  String 、枚举类型都是转换成整型之后再使用  switch 的。**</code></pre><hr><h4 id="7-可变参数"><a href="#7-可变参数" class="headerlink" title="7. 可变参数"></a>7. 可变参数</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 可变参数 * option: --arrayiter false *&#x2F;public void varargsTest(String ... arr) &#123;    for (String s : arr) &#123;        System.out.println(s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar varargsTest.class --arrayiter false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void varargsTest(String ... arr) &#123;    String[] stringArray &#x3D; arr;    int n &#x3D; arr.length;    int n2 &#x3D; 0;    while (n2 &lt; n) &#123;        String s &#x3D; stringArray[n2];        System.out.println(s);        ++n2;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 可变参数其实就是一个不定长度的数组, 数组长度随传入方法的对应参数个数来决定。可变参数只能在参数列表的末位使用。</code></pre><hr><h4 id="8-自动装箱-拆箱"><a href="#8-自动装箱-拆箱" class="headerlink" title="8. 自动装箱/拆箱"></a>8. 自动装箱/拆箱</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 自动装箱&#x2F;拆箱 * option: --sugarboxing false *&#x2F;public Double autoBoxingTest(Integer i, Double d) &#123;    return d + i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar autoBoxingTest.class --sugarboxing false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public Double autoBoxingTest(Integer i, Double d) &#123;    return Double.valueOf((double)(d.doubleValue() + (double)i.intValue()));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 首先我们知道, 基本类型与包装类型在某些操作符的作用下, 包装类型调用 `valueOf()` 方法的过程叫做装箱, 调用 `xxxValue()` 方法的过程叫做拆箱。所以上面的结果很容易看出, 先对两个包装类进行拆箱, 再对运算结果进行装箱。</code></pre><hr><h4 id="9-内部类"><a href="#9-内部类" class="headerlink" title="9. 内部类"></a>9. 内部类</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int x &#x3D; 3;&#x2F;*** 内部类* option: --removeinnerclasssynthetics false*&#x2F;public class StringTest &#123;    public void innerClassTest() &#123;        new InnerClass().getSum(6);    &#125;    public class InnerClass &#123;        public int getSum(int y) &#123;            x +&#x3D; y;            return x;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar StringTest.class --removeinnerclasssynthetics false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void innerClassTest() &#123;    new InnerClass(this).getSum(6);&#125;public class InnerClass &#123;    final &#x2F;* synthetic *&#x2F; StringTest this$0;    public InnerClass(StringTest stringTest) &#123;        this.this$0 &#x3D; stringTest;    &#125;    public int getSum(int y) &#123;        this.this$0.x +&#x3D; y;        return this.this$0.x;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 首先我们要明确, 上述 `innerClassTest()` 方法中的 `this` 是外部类当前对象的引用, 而 `InnerClass` 类中的 `this` 则是内部类当前对象的引用。编译过程中, 编译器会自动在内部类定义一个外部类的常量引用 `this$0`, 并且在内部类的构造器中初始化 `this$0`, 当外部类访问内部类时, 会把当前外部类的对象引用 `this` 传给内部类的构造器用于初始化, 这样内部类就能通过所持有的外部类的对象引用, 来访问外部类的所有公有及私有成员。&gt; - 另外，`StringTest.java` 里面定义了一个内部类 `InnerClass` ，一旦编译成功，就会生成两个完全不同的 `.class` 文件了，分别是 `StringTest.class` 和 `StringTest$InnerClass.class` 。所以内部类的名字完全可以和它的外部类名字相同。</code></pre><hr><h4 id="10-泛型擦除"><a href="#10-泛型擦除" class="headerlink" title="10. 泛型擦除"></a>10. 泛型擦除</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;*** 泛型擦除* option: 不需要参数*&#x2F;public void genericEraseTest() &#123;    List&lt;String&gt; list &#x3D;  new ArrayList&lt;String&gt;();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar genericEraseTest.class<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void genericEraseTest() &#123;    ArrayList list &#x3D; new ArrayList();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 在 `JVM` 中没有泛型这一概念,  只有普通方法和普通类, 所有泛型类的泛型参数都会在编译时期被擦除, 所以泛型类并没有自己独有的 `Class` 类对象比如 `List&lt;Integer&gt;.class` , 而只有 `List.class` 对象。</code></pre><hr><h4 id="11-增强-For-循环"><a href="#11-增强-For-循环" class="headerlink" title="11. 增强 For 循环"></a>11. 增强 For 循环</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 增强for循环 * option: --collectioniter false *&#x2F;public void forLoopTest() &#123;    String[] qingshanli &#x3D; &#123;&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&#125;;      List&lt;String&gt; list &#x3D;  Arrays.asList(qingshanli);    for (Object s : list) &#123;        System.out.println(s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar forLoopTest.class --collectioniter false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void forLoopTest() &#123;    String[] qingshanli &#x3D; new String[]&#123;&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&#125;;    List&lt;String&gt; list &#x3D; Arrays.asList(qingshanli);    Iterator&lt;String&gt; iterator &#x3D; list.iterator();    while (iterator.hasNext()) &#123;        String s &#x3D; iterator.next();        System.out.println((Object)s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 很明显, 增强for循环的底层其实还是通过迭代器来实现的, 这也就解释了为什么增强for循环中不能进行增删改操作。&gt; - 补充：`Iterator` 是工作在一个独立的线程中，并且拥有一个` mutex` 锁。 `Iterator` 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候,若对象内容发生了改变，就可能找不到要迭代的对象，所以按照 `fail-fast` 原则 `Iterator` 会马上抛出 `java.util.ConcurrentModificationException` 异常。</code></pre><hr><h4 id="12-lambda表达式"><a href="#12-lambda表达式" class="headerlink" title="12. lambda表达式"></a>12. lambda表达式</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;*** lambda表达式* option: --decodelambdas false*&#x2F;public void lambdaTest() &#123;    String[] qingshanli &#x3D; &#123;&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&#125;;      List&lt;String&gt; list &#x3D;  Arrays.asList(qingshanli);    &#x2F;&#x2F; 使用lambda表达式以及函数操作    list.forEach((str) -&gt; System.out.print(str + &quot;; &quot;));    &#x2F;&#x2F; 在JDK8中使用双冒号操作符    list.forEach(System.out::println);  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar lambdaTest.class --decodelambdas false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void lambdaTest() &#123;    String[] qingshanli &#x3D; new String[]&#123;&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&#125;;    List&lt;String&gt; list &#x3D; Arrays.asList(qingshanli);    list.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava&#x2F;lang&#x2F;Object;)V, lambda$0(java.lang.String ), (Ljava&#x2F;lang&#x2F;String;)V)());    PrintStream printStream &#x3D; System.out;    printStream.getClass();    list.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava&#x2F;lang&#x2F;Object;)V, println(java.lang.String ), (Ljava&#x2F;lang&#x2F;String;)V)((PrintStream)printStream));&#125;private static &#x2F;* synthetic *&#x2F; void lambda$0(String str) &#123;    System.out.print(String.valueOf(str) + &quot;; &quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 可以看到，在 `forEach` 方法中，其实是调用了 `java.lang.invoke.LambdaMetafactory#metafactory` 方法，该方法的第四个参数 `implMethod` 指定了方法实现。可以看到这里其实是调用了一个 `lambda$0` 方法进行了输出。&gt; - 所以，`lambda` 表达式的实现其实是依赖了一些底层的 API，在编译阶段，编译器会把 `lambda` 表达式进行解糖，转换成调用内部 API 的方式。&gt; - `JDK8` 中新增的双冒号的用法其实和 `lambda` 表达式在底层实现是一样的，就是把方法当做参数传到 `stream` 内部，使 `stream` 的每个元素都传入到该方法里面执行一下。在 `JDK8` 中，接口 `Iterable` 中默认实现了 `forEach` 方法，调用了 `JDK8` 中增加的接口 `Consumer` 内的 `accept` 方法，执行传入的方法参数。</code></pre><hr><h4 id="13-try-with-resources语句"><a href="#13-try-with-resources语句" class="headerlink" title="13. try-with-resources语句"></a>13. try-with-resources语句</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;*** try-with-resources语句* option: --tryresources false*&#x2F;public void tryWithResourcesTest() throws IOException &#123;    try (final StringWriter writer &#x3D; new StringWriter();        final StringWriter writer2 &#x3D; new StringWriter()) &#123;        writer.write(&quot;This is qingshanli1&quot;);        writer2.write(&quot;this is qingshanli2&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar tryWithResourcesTest.class --tryresources false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;* * Enabled force condition propagation * Lifted jumps to return sites *&#x2F;public void tryWithResourcesTest() throws IOException &#123;    Throwable throwable &#x3D; null;    Object var2_3 &#x3D; null;    try &#123;        StringWriter writer &#x3D; new StringWriter();        try &#123;            StringWriter writer2 &#x3D; new StringWriter();            try &#123;                writer.write(&quot;This is qingshanli1&quot;);                writer2.write(&quot;this is qingshanli2&quot;);            &#125;            finally &#123;                if (writer2 !&#x3D; null) &#123;                    writer2.close();                &#125;            &#125;            if (writer &#x3D;&#x3D; null) return;        &#125;        catch (Throwable throwable2) &#123;            if (throwable &#x3D;&#x3D; null) &#123;                throwable &#x3D; throwable2;            &#125; else if (throwable !&#x3D; throwable2) &#123;                throwable.addSuppressed(throwable2);            &#125;            if (writer &#x3D;&#x3D; null) throw throwable;            writer.close();            throw throwable;        &#125;        writer.close();        return;    &#125;    catch (Throwable throwable3) &#123;        if (throwable &#x3D;&#x3D; null) &#123;            throwable &#x3D; throwable3;            throw throwable;        &#125; else &#123;            if (throwable &#x3D;&#x3D; throwable3) throw throwable;            throwable.addSuppressed(throwable3);        &#125;        throw throwable;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 在 `JDK7` 之前, 如 `IO` 流、数据库连接等资源用完后, 都是通过 `finally` 代码块来释放资源。而 `try-with-resources` 语法糖则帮我们省去了释放资源这一操作, 编译器在解语法糖阶段时会将它还原成原始的语法结构。</code></pre><hr><h4 id="14-数字字面量"><a href="#14-数字字面量" class="headerlink" title="14. 数字字面量"></a>14. 数字字面量</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * literal字面量 * option: *&#x2F;public void literalTest() &#123;    int i &#x3D; 10_000;    System.out.println(i);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar literalTest.class<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void literalTest() &#123;    int i &#x3D; 10000;    System.out.println(i);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 反编译后就是把 `_` 删除了。也就是说编译器并不认识在数字字面量中的 `_` ，需要在编译阶段把他去掉。</code></pre><hr>]]></content>
    
    
    <summary type="html">对Java语言中的语法糖进行解糖深入剖析</summary>
    
    
    
    <category term="Java" scheme="https://www.onexstone.online/categories/Java/"/>
    
    
    <category term="语法糖" scheme="https://www.onexstone.online/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议之状态码</title>
    <link href="https://www.onexstone.online/posts/d9c27918/"/>
    <id>https://www.onexstone.online/posts/d9c27918/</id>
    <published>2021-09-26T06:16:54.000Z</published>
    <updated>2021-09-26T06:24:35.912Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文是从客户端角度出发，解析服务器端发送而来的状态码的具体含义。</p><span id="more"></span><h3 id="1××-Informational-通知"><a href="#1××-Informational-通知" class="headerlink" title="1×× Informational 通知"></a>1×× Informational 通知</h3><ol><li> 1xx 状态码仅适用于 <strong>HTTP 1.1</strong> 版本及以上。</li></ol><h4 id="100-Continue-继续"><a href="#100-Continue-继续" class="headerlink" title="100 Continue 继续"></a>100 <strong>Continue</strong> 继续</h4><blockquote><ul><li>  请求的初始部分已收到，但尚未被服务器拒绝。服务器打算在请求被完全收到并采取行动后发送最终响应。</li><li>  当请求包含一个包含 <strong>100-continue</strong> 期望的 <strong>Expect</strong> 标头字段时，<strong>100</strong> 响应表示服务器希望收到请求负载正文。客户端应该继续发送请求并丢弃 <strong>100</strong> 响应。</li><li>  如果请求不包含包含 <strong>100-continue</strong> 期望的 <strong>Expect</strong> 标头字段，则客户端可以简单地丢弃此临时响应。</li></ul></blockquote><h4 id="101-Switching-Protocols-切换协议"><a href="#101-Switching-Protocols-切换协议" class="headerlink" title="101 Switching Protocols 切换协议"></a>101 <strong>Switching Protocols</strong> 切换协议</h4><blockquote><ul><li>  服务器了解并愿意通过升级头字段遵守客户端的请求，以更改此连接上正在使用的应用程序协议。</li><li>  服务器必须在响应中生成一个升级头字段，指示在终止 <strong>101</strong> 响应的空行之后将立即切换到哪个协议。</li><li>  注：服务器通常仅在有利时才同意切换协议。例如，切换到较新版本的 <strong>HTTP</strong> 可能比旧版本更有优势，或者切换到实时、同步的协议在交互传输资源时可能更有优势。</li></ul></blockquote><h4 id="102-Processing-处理中"><a href="#102-Processing-处理中" class="headerlink" title="102 Processing 处理中"></a>102 <strong>Processing</strong> 处理中</h4><blockquote><ul><li>  用于通知客户端，服务器已接受完整请求但尚未完成时做出的临时响应。</li><li>  这个状态码应该只在服务器知道请求可能需要很长时间才能完成时发送。假如一个方法需要超过 20 秒（一个合理但任意的值）来处理，服务器就应该返回一个 <strong>102（Processing）</strong> 响应告知客户端该请求目前仍在处理中。服务器必须在请求完成后发送最终响应。</li><li>  方法可能需要很长时间来处理，尤其是支持 <strong>Depth</strong> 标头的方法。在这种情况下，客户端可能会在等待响应时超时连接。为了防止这种情况，服务器可能会返回 <strong>102 Processing</strong> 状态代码以向客户端指示服务器仍在处理该方法。</li></ul></blockquote><hr><h3 id="2××-Success-请求成功返回"><a href="#2××-Success-请求成功返回" class="headerlink" title="2×× Success 请求成功返回"></a>2×× Success 请求成功返回</h3><h4 id="200-OK-成功"><a href="#200-OK-成功" class="headerlink" title="200 OK 成功"></a>200 <strong>OK</strong> 成功</h4><blockquote><ul><li>  请求已成功。</li><li>  200 响应中发送的负载取决于请求方法。对于本规范（<strong>RFC7231</strong>）定义的方法，有效载荷的预期含义可以概括为：</li><li>  <strong>GET</strong> 表示目标资源</li><li>  <strong>HEAD</strong> 与 GET 含义相同，但没有数据</li><li><strong>POST</strong> 表示处理动作的状态或结果；<ul><li>  <strong>PUT DELETE</strong> 表示处理动作状态；</li><li>  <strong>OPTIONS</strong> 表示可选的通信选项；</li><li>  <strong>TRACE</strong> 表示终端服务器收到的请求消息。</li></ul></li><li>  除了对 <strong>CONNECT</strong> 的响应之外，200 响应始终具有有效负载，尽管源服务器可能会生成零长度的有效负载主体。如果不需要有效负载，源服务器应该发送 <strong>204 No Content</strong> 代替。对于 <strong>CONNECT</strong>，不允许有效负载，因为成功的结果是创建一个隧道，该隧道在 200 响应之后立即开始。</li><li>  默认情况下，200 响应是可缓存的；除非方法定义或显式缓存控件另有说明。</li></ul></blockquote><h4 id="201-Created-请求成功，并创建了新的资源"><a href="#201-Created-请求成功，并创建了新的资源" class="headerlink" title="201 Created 请求成功，并创建了新的资源"></a>201 <strong>Created</strong> 请求成功，并创建了新的资源</h4><blockquote><ul><li>  请求已完成并导致创建一个或多个新资源。</li><li>  请求创建的主要资源由响应中的 <strong>Location</strong> 头字段标识，或者，如果没有收到 <strong>Location</strong> 字段，则由有效的请求 URI 标识。</li><li>  201 响应负载通常描述并链接到所创建的资源。</li></ul></blockquote><h4 id="202-Accepted-请求已接受但未处理完成"><a href="#202-Accepted-请求已接受但未处理完成" class="headerlink" title="202 Accepted 请求已接受但未处理完成"></a>202 <strong>Accepted</strong> 请求已接受但未处理完成</h4><blockquote><ul><li>  请求已被接受进行处理，但处理尚未完成。该请求最终可能会或可能不会被执行，因为在实际进行处理时可能会被禁止。</li><li>  <strong>HTTP</strong> 中没有用于从异步操作重新发送状态代码的工具。</li><li>  202 响应的目的是允许服务器接受对某个其他进程（可能是一个每天只运行一次的面向批处理的进程）的请求，而无需用户代理与服务器的连接持续到该进程完成。与此响应一起发送的表示应该描述请求的当前状态并指向（或嵌入）一个状态监视器，该监视器可以为用户提供请求何时完成的估计。</li></ul></blockquote><h4 id="203-Non-authoritative-Information-返回的是非权威（非官方）内容"><a href="#203-Non-authoritative-Information-返回的是非权威（非官方）内容" class="headerlink" title="203 Non-authoritative Information 返回的是非权威（非官方）内容"></a>203 <strong>Non-authoritative Information</strong> 返回的是非权威（非官方）内容</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回 <strong>200 OK</strong> 的情况下才是合适的。</li><li>  简单地说，就是通过代理访问原始服务器的时候，成功获取了原始服务器（状态码 <strong>200</strong>）的返回内容，但代理对内容做出了一些改动，例如修改了文档编码等等，代理通过这个状态码告知客户端，成功获取内容，但这部分内容和原始服务器的返回内容可能不完全一致。</li></ul></blockquote><h4 id="204-No-Content-无内容（请求收到，但返回信息为空）"><a href="#204-No-Content-无内容（请求收到，但返回信息为空）" class="headerlink" title="204 No Content 无内容（请求收到，但返回信息为空）"></a>204 <strong>No Content</strong> 无内容（请求收到，但返回信息为空）</h4><blockquote><ul><li>  服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。</li><li>  如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。</li><li>  由于 <strong>204</strong> 响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</li></ul></blockquote><h4 id="205-Reset-Content-重置视图内容（请求已完成，要求客户端复位视图）"><a href="#205-Reset-Content-重置视图内容（请求已完成，要求客户端复位视图）" class="headerlink" title="205 Reset Content 重置视图内容（请求已完成，要求客户端复位视图）"></a>205 <strong>Reset Content</strong> 重置视图内容（请求已完成，要求客户端复位视图）</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器成功处理了请求，且没有返回任何内容。但是与 <strong>204</strong> 响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。</li><li>  与 <strong>204</strong> 响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</li></ul></blockquote><h4 id="206-Partial-Content-部分处理"><a href="#206-Partial-Content-部分处理" class="headerlink" title="206 Partial Content 部分处理"></a>206 <strong>Partial Content</strong> 部分处理</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  表示该服务器已经成功处理了部分 <strong>GET</strong> 请求。类似于 <strong>FlashGet</strong> 或者迅雷这类的 <strong>HTTP</strong> 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</li><li>  该请求必须包含 <strong>Range</strong> 头信息来指示客户端希望得到的内容范围，并且可能包含 <strong>If-Range</strong> 来作为请求条件。</li><li>响应必须包含如下的头部域：<ul><li>  <strong>Content-Range</strong> 用以指示本次响应中返回的内容的范围；如果是 <strong>Content-Type</strong> 为 <strong>multipart/byteranges</strong> 的多段下载，则每一 <strong>multipart</strong> 段中都应包含 <strong>Content-Range</strong> 域用以指示本段的内容范围。假如响应中包含 <strong>Content-Length</strong>，那么它的数值必须匹配它返回的内容范围的真实字节数</li></ul></li></ul></blockquote><h4 id="207-Multi-Status-多状态响应"><a href="#207-Multi-Status-多状态响应" class="headerlink" title="207 Multi-Status 多状态响应"></a>207 <strong>Multi-Status</strong> 多状态响应</h4><blockquote><ul><li>  由 <strong>WebDAV（RFC2518）</strong> 扩展的状态码，代表之后的消息体将是一个 <strong>XML</strong> 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</li></ul></blockquote><h4 id="208-Already-Reported-已经报告"><a href="#208-Already-Reported-已经报告" class="headerlink" title="208 Already Reported 已经报告"></a>208 <strong>Already Reported</strong> 已经报告</h4><blockquote><ul><li>  一个 <strong>DAV</strong> 的绑定成员被前一个请求枚举，并且没有被再一次包括。</li></ul></blockquote><h4 id="226-IM-Used"><a href="#226-IM-Used" class="headerlink" title="226 IM Used"></a>226 <strong>IM Used</strong></h4><blockquote><ul><li>  服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实例的结果。</li></ul></blockquote><hr><h3 id="3××-Redirection-重定向"><a href="#3××-Redirection-重定向" class="headerlink" title="3×× Redirection 重定向"></a>3×× Redirection 重定向</h3><h4 id="300-Multiple-Choices-多重选择"><a href="#300-Multiple-Choices-多重选择" class="headerlink" title="300 Multiple Choices 多重选择"></a>300 <strong>Multiple Choices</strong> 多重选择</h4><blockquote><ul><li>  客户请求的资源可以在多个位置找到，这些位置已经在返回的载荷内列出。如果服务器要提出优先选择，则应该在 <strong>Location</strong> 应答头指明。</li><li>  除非这是一个 <strong>HEAD</strong> 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 <strong>Content-Type</strong> 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，<strong>RFC 2616</strong> 规范并没有规定这样的自动选择该如何进行。</li><li>  如果服务器本身已经有了首选的回馈选择，那么在 <strong>Location</strong> 中应当指明这个回馈的 <strong>URI</strong>；浏览器可能会将这个 <strong>Location</strong> 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</li></ul></blockquote><h4 id="301-Moved-Permanently-永久移动（永久重定向）"><a href="#301-Moved-Permanently-永久移动（永久重定向）" class="headerlink" title="301 Moved Permanently 永久移动（永久重定向）"></a>301 <strong>Moved Permanently</strong> 永久移动（永久重定向）</h4><blockquote><ul><li>  客户请求的资源在其他地方，新的 <strong>URL</strong> 在 <strong>Location</strong> 头中给出，浏览器应该自动地访问新的 <strong>URL</strong>。</li><li>  除非这是一个 <strong>HEAD</strong> 请求，否则响应的实体中应当包含指向新的 <strong>URI</strong> 的超链接及简短说明。</li><li>  如果这不是一个 <strong>GET</strong> 或者 <strong>HEAD</strong> 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</li><li>  注意：对于某些使用 <strong>HTTP/1.0</strong> 协议的浏览器，当它们发送的 <strong>POST</strong> 请求得到了一个 <strong>301</strong> 响应的话，接下来的重定向请求将会变成 <strong>GET</strong> 方式。</li></ul></blockquote><h4 id="302-Found-临时性重定向"><a href="#302-Found-临时性重定向" class="headerlink" title="302 Found 临时性重定向"></a>302 <strong>Found</strong> 临时性重定向</h4><blockquote><ul><li>  要求客户端执行临时重定向（原始描述短语为 <strong>Moved Temporarily</strong> ）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 <strong>Cache-Control</strong> 或 <strong>Expires</strong> 中进行了指定的情况下，这个响应才是可缓存的。</li><li>  新的临时性的 <strong>URI</strong> 应当在响应的 <strong>Location</strong> 域中返回。除非这是一个 <strong>HEAD</strong> 请求，否则响应的实体中应当包含指向新的 <strong>URI</strong> 的超链接及简短说明。 如果这不是一个 <strong>GET</strong> 或者 <strong>HEAD</strong> 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</li><li>  注意：虽然 <strong>RFC 1945</strong> 和 <strong>RFC 2068</strong> 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 <strong>302</strong> 响应视作为 <strong>303</strong> 响应，并且使用 <strong>GET</strong> 方式访问在 <strong>Location</strong> 中规定的 <strong>URI</strong>，而无视原先请求的方法。因此状态码 <strong>303</strong> 和 <strong>307</strong> 被添加了进来，用以明确服务器期待客户端进行何种反应。</li></ul></blockquote><h4 id="303-See-Other-查看其它（返回新的资源-URI）"><a href="#303-See-Other-查看其它（返回新的资源-URI）" class="headerlink" title="303 See Other 查看其它（返回新的资源 URI）"></a>303 <strong>See Other</strong> 查看其它（返回新的资源 URI）</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  对应当前请求的响应可以在另一个 <strong>URI</strong> 上被找到，而且客户端应当采用 <strong>GET</strong> 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的 <strong>POST</strong> 请求输出重定向到一个新的资源。这个新的 <strong>URI</strong> 不是原始资源的替代引用。同时，<strong>303</strong>响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</li><li>  注意：许多 <strong>HTTP/1.1</strong> 版以前的浏览器不能正确理解 <strong>303</strong> 状态。如果需要考虑与这些浏览器之间的互动， 状态码应该可以胜任，因为大多数的浏览器处理 <strong>302</strong> 响应时的方式恰恰就是上述规范要求客户端处理 <strong>303</strong> 响应时应当做的。</li></ul></blockquote><h4 id="304-Not-Modified-未修改"><a href="#304-Not-Modified-未修改" class="headerlink" title="304 Not Modified 未修改"></a>304 <strong>Not Modified</strong> 未修改</h4><blockquote><ul><li>  客户端有缓冲的资源并发出了一个条件性的请求（一般是提供 <strong>If-Modified-Since</strong> 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</li></ul></blockquote><h4 id="305-Use-Proxy-使用代理"><a href="#305-Use-Proxy-使用代理" class="headerlink" title="305 Use Proxy 使用代理"></a>305 <strong>Use Proxy</strong> 使用代理</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  客户请求的资源应该通过 <strong>Location</strong> 头所指明的代理服务器提取。</li></ul></blockquote><h4 id="305-Switch-Proxy-切换代理"><a href="#305-Switch-Proxy-切换代理" class="headerlink" title="305 Switch Proxy 切换代理"></a><del>305 <strong>Switch Proxy</strong> 切换代理</del></h4><blockquote><ul><li>  在最新版的规范中，306状态码已经不再被使用。</li></ul></blockquote><h4 id="307-Temporary-Redirect-临时跳转"><a href="#307-Temporary-Redirect-临时跳转" class="headerlink" title="307 Temporary Redirect 临时跳转"></a>307 <strong>Temporary Redirect</strong> 临时跳转</h4><blockquote><ul><li>  <strong>HTTP 1.1</strong> 新增了 <strong>307</strong> ，以便更加清除地区分几个状态代码：当出现 <strong>303</strong> 应答时，客户端可以跟随重定向的 <strong>GET</strong> 和 <strong>POST</strong> 请求；如果是 <strong>303</strong> 应答，则客户端只能跟随对 <strong>POST</strong> 请求的重定向；如果是 <strong>307</strong> 应答，则客户端只能跟随对 <strong>GET</strong> 请求的重定向。</li></ul></blockquote><h4 id="308-Permanent-Redirect-永久跳转"><a href="#308-Permanent-Redirect-永久跳转" class="headerlink" title="308 Permanent Redirect 永久跳转"></a>308 <strong>Permanent Redirect</strong> 永久跳转</h4><blockquote><ul><li>  这个请求和以后的请求都应该被另一个 <strong>URI</strong> 地址重新发送。<strong>307、308</strong>和 <strong>302、301</strong> 有相同的表现，但是不允许 <strong>HTTP</strong> 方法改变。例如，请求表单到一个永久转移的资源将会继续顺利地执行。</li></ul></blockquote><hr><h3 id="4××-Client-Error-客户端错误"><a href="#4××-Client-Error-客户端错误" class="headerlink" title="4×× Client Error 客户端错误"></a>4×× Client Error 客户端错误</h3><h4 id="400-Bad-Request-错误请求"><a href="#400-Bad-Request-错误请求" class="headerlink" title="400 Bad Request 错误请求"></a>400 <strong>Bad Request</strong> 错误请求</h4><blockquote><ul><li>  请求出现语法错误。</li></ul></blockquote><h4 id="401-Unauthorized-未授权"><a href="#401-Unauthorized-未授权" class="headerlink" title="401 Unauthorized 未授权"></a>401 <strong>Unauthorized</strong> 未授权</h4><blockquote><ul><li>访问被拒绝，客户试图未经授权访问受密码保护的页面。应答中会包含一个 <strong>WWW-Authenticate</strong> 头，浏览器据此显示用户名字/密码对话框，然后在填写合适的 <strong>Authorization</strong> 头后再次发出请求。<strong>IIS</strong> 定义了许多不同的 <strong>401</strong> 错误，它们指明更为具体的错误原因。这些具体的错误代码在客户端中显示，但不在 <strong>IIS</strong> 日志中显示：<ul><li>  401.1 - 登录失败。</li><li>  401.2 - 服务器配置导致登录失败。</li><li>  401.3 - 由于 <strong>ACL</strong> 对资源的限制而未获得授权。</li><li>  401.4 - 筛选器授权失败。</li><li>  401.5 - <strong>ISAPI/CGI</strong> 应用程序授权失败。</li><li>  401.7 – 访问被 <strong>Web</strong> 服务器上的 <strong>URL</strong> 授权策略拒绝。这个错误代码为 <strong>IIS 6.0</strong> 所专用。</li></ul></li></ul></blockquote><h4 id="402-Payment-Required-需要付款（未使用，保留状态码）"><a href="#402-Payment-Required-需要付款（未使用，保留状态码）" class="headerlink" title="402 Payment Required 需要付款（未使用，保留状态码）"></a>402 <strong>Payment Required</strong> 需要付款（未使用，保留状态码）</h4><blockquote><ul><li>  为以后保留使用。原意是该状态码可被用于一些数字货币或者是微支付，但是目前还没有普及，所以这些代码不经常被使用。</li></ul></blockquote><h4 id="403-Forbidden-禁止访问"><a href="#403-Forbidden-禁止访问" class="headerlink" title="403 Forbidden 禁止访问"></a>403 <strong>Forbidden</strong> 禁止访问</h4><blockquote><ul><li>资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。<strong>IIS</strong> 定义了许多不同的 <strong>403</strong> 错误，它们指明更为具体的错误原因：<ul><li>  403.1 - 执行访问被禁止。</li><li>  403.2 - 读访问被禁止。</li><li>  403.3 - 写访问被禁止。</li><li>  403.4 - 要求 <strong>SSL</strong>。</li><li>  403.5 - 要求 <strong>SSL 128</strong>。</li><li>  403.6 - IP 地址被拒绝。</li><li>  403.7 - 要求客户端证书。</li><li>  403.8 - 站点访问被拒绝。</li><li>  403.9 - 用户数过多。</li><li>  403.10 - 配置无效。</li><li>  403.11 - 密码更改。</li><li>  403.12 - 拒绝访问映射表。</li><li>  403.13 - 客户端证书被吊销。</li><li>  403.14 - 拒绝目录列表。</li><li>  403.15 - 超出客户端访问许可。</li><li>  403.16 - 客户端证书不受信任或无效。</li><li>  403.17 - 客户端证书已过期或尚未生效。</li><li>  403.18 - 在当前的应用程序池中不能执行所请求的 <strong>URL</strong>。这个错误代码为 IIS 6.0 所专用。</li><li>  403.19 - 不能为这个应用程序池中的客户端执行 <strong>CGI</strong>。这个错误代码为 IIS 6.0 所专用。</li><li>  403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</li></ul></li></ul></blockquote><h4 id="404-Not-Found-资源找不到"><a href="#404-Not-Found-资源找不到" class="headerlink" title="404 Not Found 资源找不到"></a>404 <strong>Not Found</strong> 资源找不到</h4><blockquote><ul><li>  无法找到指定位置的资源。</li><li>  没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 <strong>410</strong> 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。</li></ul></blockquote><h4 id="405-Method-Not-Allowed-方法不允许（请求方法错误）"><a href="#405-Method-Not-Allowed-方法不允许（请求方法错误）" class="headerlink" title="405 Method Not Allowed 方法不允许（请求方法错误）"></a>405 <strong>Method Not Allowed</strong> 方法不允许（请求方法错误）</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 <strong>Allow</strong> 头信息用以表示出当前资源能够接受的请求方法的列表。</li><li>  请求方法（<strong>GET、POST、HEAD、Delete、PUT、TRACE等</strong>）对指定的资源不适用，用来访问本页面的 <strong>HTTP</strong> 谓词不被允许（方法不被允许）</li></ul></blockquote><h4 id="406-Not-Acceptable-不可接受"><a href="#406-Not-Acceptable-不可接受" class="headerlink" title="406 Not Acceptable 不可接受"></a>406 <strong>Not Acceptable</strong> 不可接受</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  指定的资源已经找到，但它的 <strong>MIME</strong> 类型和客户在 <strong>Accpet</strong> 头中所指定的不兼容，客户端浏览器不接受所请求页面的 <strong>MIME</strong> 类型。</li></ul></blockquote><h4 id="407-Proxy-Authentication-Required-需要代理认证"><a href="#407-Proxy-Authentication-Required-需要代理认证" class="headerlink" title="407 Proxy Authentication Required 需要代理认证"></a>407 <strong>Proxy Authentication Required</strong> 需要代理认证</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  要求进行代理身份验证，类似于 <strong>401</strong> ，表示客户必须先经过代理服务器的授权。</li></ul></blockquote><h4 id="408-Request-Timeout-请求超时"><a href="#408-Request-Timeout-请求超时" class="headerlink" title="408 Request Timeout 请求超时"></a>408 <strong>Request Timeout</strong> 请求超时</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</li></ul></blockquote><h4 id="409-Conflict-冲突"><a href="#409-Conflict-冲突" class="headerlink" title="409 Conflict 冲突"></a>409 <strong>Conflict</strong> 冲突</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  通常和 <strong>PUT</strong> 请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。</li></ul></blockquote><h4 id="410-Gone-资源丢失"><a href="#410-Gone-资源丢失" class="headerlink" title="410 Gone 资源丢失"></a>410 <strong>Gone</strong> 资源丢失</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  所请求的资源档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和 <strong>404</strong> 的不同在于，返回 <strong>407</strong> 表示资源永久地离开了指定的位置，而 <strong>404</strong> 表示由于未知的原因资源不可用。</li></ul></blockquote><h4 id="411-Length-Required-长度要求"><a href="#411-Length-Required-长度要求" class="headerlink" title="411 Length Required 长度要求"></a>411 <strong>Length Required</strong> 长度要求</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器不能处理请求，除非客户发送一个 <strong>Content-Length</strong> 头。</li></ul></blockquote><h4 id="412-Precondition-Failed-前置条件错误"><a href="#412-Precondition-Failed-前置条件错误" class="headerlink" title="412 Precondition Failed 前置条件错误"></a>412 <strong>Precondition Failed</strong> 前置条件错误</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  请求头中指定的一些前提条件失败。</li><li>  这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</li></ul></blockquote><h4 id="413-Payload-Too-Large-响应实体太长"><a href="#413-Payload-Too-Large-响应实体太长" class="headerlink" title="413 Payload Too Large 响应实体太长"></a>413 <strong>Payload Too Large</strong> 响应实体太长</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</li><li>  如果这个状况是临时的，服务器应当返回一个 <strong>Retry-After</strong> 的响应头，以告知客户端可以在多少时间以后重新尝试</li></ul></blockquote><h4 id="414-Request-URI-Too-Long-请求-URI-太长"><a href="#414-Request-URI-Too-Long-请求-URI-太长" class="headerlink" title="414 Request-URI Too Long 请求 URI 太长"></a>414 <strong>Request-URI Too Long</strong> 请求 URI 太长</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  客户端提供的URI对服务器的处理来说太长。经常出现在太多被编码的数据被作为查询字符串的 <strong>GET</strong> 请求的结果，因此需要被转换为 <strong>POST</strong> 请求。</li></ul></blockquote><h4 id="415-Unsupported-Media-Type-不支持的媒体类型"><a href="#415-Unsupported-Media-Type-不支持的媒体类型" class="headerlink" title="415 Unsupported Media Type 不支持的媒体类型"></a>415 <strong>Unsupported Media Type</strong> 不支持的媒体类型</h4><blockquote><ul><li>  请求实体的媒体类型不被服务器或者资源支持。例如，客户端上传一个 <strong>image/svg+xml</strong> 的图片，但是服务器需要图片使用不同的格式。</li></ul></blockquote><h4 id="416-Requested-Range-Not-Satisfiable-请求范围不能满足"><a href="#416-Requested-Range-Not-Satisfiable-请求范围不能满足" class="headerlink" title="416 Requested Range Not Satisfiable 请求范围不能满足"></a>416 <strong>Requested Range Not Satisfiable</strong> 请求范围不能满足</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器不能满足客户在请求中指定的 <strong>Range</strong> 头。</li></ul></blockquote><h4 id="417-Expectation-Failed-执行失败"><a href="#417-Expectation-Failed-执行失败" class="headerlink" title="417 Expectation Failed 执行失败"></a>417 <strong>Expectation Failed</strong> 执行失败</h4><blockquote><ul><li>  在请求头 <strong>Expect</strong> 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，<strong>Expect</strong> 的内容无法被满足。</li></ul></blockquote><h4 id="418-I’m-a-teapot-我是茶壶"><a href="#418-I’m-a-teapot-我是茶壶" class="headerlink" title="418 I’m a teapot 我是茶壶"></a>418 <strong>I’m a teapot</strong> <del>我是茶壶</del></h4><blockquote><ul><li>  这个代码是在 1998 年作为传统的 <strong>IETF April Fools‘ jokes</strong> 被定义的在 <strong>RFC2324</strong>，超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现。RFC指定了这个代码应该是由茶罐返回给速溶咖啡。</li></ul></blockquote><h4 id="421-Misdirected-Request-误导请求"><a href="#421-Misdirected-Request-误导请求" class="headerlink" title="421 Misdirected Request 误导请求"></a>421 <strong>Misdirected Request</strong> 误导请求</h4><blockquote><ul><li>  请求被直接定向到不能产生响应的服务器上（例如因为一个连接的复用）。</li></ul></blockquote><h4 id="422-Unprocessable-Entity-不可处理的实体"><a href="#422-Unprocessable-Entity-不可处理的实体" class="headerlink" title="422 Unprocessable Entity 不可处理的实体"></a>422 <strong>Unprocessable Entity</strong> 不可处理的实体</h4><blockquote><ul><li>  请求格式正确，但是由于含有语义错误，无法响应。</li></ul></blockquote><h4 id="423-Locked-锁定"><a href="#423-Locked-锁定" class="headerlink" title="423 Locked 锁定"></a>423 <strong>Locked</strong> 锁定</h4><blockquote><ul><li>  当前资源被锁定。</li></ul></blockquote><h4 id="424-Failed-Dependency-失败的依赖"><a href="#424-Failed-Dependency-失败的依赖" class="headerlink" title="424 Failed Dependency 失败的依赖"></a>424 <strong>Failed Dependency</strong> 失败的依赖</h4><blockquote><ul><li>  由于之前的某个请求发生的错误，导致当前请求失败，例如 <strong>PROPPATCH</strong>。</li></ul></blockquote><h4 id="426-Upgrade-Required-需要升级"><a href="#426-Upgrade-Required-需要升级" class="headerlink" title="426 Upgrade Required 需要升级"></a>426 <strong>Upgrade Required</strong> 需要升级</h4><blockquote><ul><li>  客户端应该切换不同的协议，例如 <strong>TLS/1.0</strong> （RFC 2817）。</li></ul></blockquote><h4 id="428-Precondition-Required-需要前置条件"><a href="#428-Precondition-Required-需要前置条件" class="headerlink" title="428 Precondition Required 需要前置条件"></a>428 <strong>Precondition Required</strong> 需要前置条件</h4><blockquote><ul><li>  原始服务器需要有条件的请求。当客户端 <strong>GET</strong> 一个资源的状态的时候，同时又 <strong>PUT</strong> 回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。</li></ul></blockquote><h4 id="429-Too-Many-Requests-过多请求"><a href="#429-Too-Many-Requests-过多请求" class="headerlink" title="429 Too Many Requests 过多请求"></a>429 <strong>Too Many Requests</strong> 过多请求</h4><blockquote><ul><li>  用户已经发送了太多的请求在指定的时间里。用于限制速率。</li></ul></blockquote><h4 id="431-Request-Header-Fields-Too-Large-请求头部字段太大"><a href="#431-Request-Header-Fields-Too-Large-请求头部字段太大" class="headerlink" title="431 Request Header Fields Too Large 请求头部字段太大"></a>431 <strong>Request Header Fields Too Large</strong> 请求头部字段太大</h4><blockquote><ul><li>  服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。</li></ul></blockquote><h4 id="444-Connection-Closed-Without-Response-无响应，连接关闭"><a href="#444-Connection-Closed-Without-Response-无响应，连接关闭" class="headerlink" title="444 Connection Closed Without Response 无响应，连接关闭"></a>444 <strong>Connection Closed Without Response</strong> 无响应，连接关闭</h4><blockquote><ul><li>  被使用在 <strong>Nginx</strong> 的日志中，表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。</li></ul></blockquote><h4 id="451-Unavailable-For-Legal-Reasons-由于法律原因而无效（因特网草稿）"><a href="#451-Unavailable-For-Legal-Reasons-由于法律原因而无效（因特网草稿）" class="headerlink" title="451 Unavailable For Legal Reasons 由于法律原因而无效（因特网草稿）"></a>451 <strong>Unavailable For Legal Reasons</strong> 由于法律原因而无效（因特网草稿）</h4><blockquote><ul><li>  被定义在因特网草稿 “一个新的HTTP状态码用于法律限制的资源” 。被用于当资源的访问由于法律原因被禁止的时候。</li></ul></blockquote><h4 id="499-Client-Closed-Request-关闭连接"><a href="#499-Client-Closed-Request-关闭连接" class="headerlink" title="499 Client Closed Request 关闭连接"></a>499 <strong>Client Closed Request</strong> 关闭连接</h4><blockquote><ul><li>  <strong>nginx</strong> 引入的非标准状态码，用于客户端在 nginx 处理请求时关闭连接的情况。</li></ul></blockquote><hr><h3 id="5××-Server-Error-服务器错误"><a href="#5××-Server-Error-服务器错误" class="headerlink" title="5×× Server Error 服务器错误"></a>5×× Server Error 服务器错误</h3><h4 id="500-Internal-Server-Error-服务器内部错误"><a href="#500-Internal-Server-Error-服务器内部错误" class="headerlink" title="500 Internal Server Error 服务器内部错误"></a>500 <strong>Internal Server Error</strong> 服务器内部错误</h4><blockquote><ul><li>服务器遇到了意料不到的情况，不能完成客户的请求。一般来说，这个问题都会在服务器端的源代码出现错误时出现。<ul><li>  500.12 - 应用程序正忙于在 <strong>Web</strong> 服务器上重新启动。</li><li>  500.13 - <strong>Web</strong> 服务器太忙。</li><li>  500.15 - 不允许直接请求 <strong>Global.asa</strong>。</li><li>  500.16 – <strong>UNC</strong> 授权凭据不正确。这个错误代码为 <strong>IIS 6.0</strong> 所专用。</li><li>  500.18 – <strong>URL</strong> 授权存储不能打开。这个错误代码为 <strong>IIS 6.0</strong> 所专用。</li><li>  500.100 - 内部 <strong>ASP</strong> 错误。</li></ul></li></ul></blockquote><h4 id="501-Not-Implemented-没有实现"><a href="#501-Not-Implemented-没有实现" class="headerlink" title="501 Not Implemented 没有实现"></a>501 <strong>Not Implemented</strong> 没有实现</h4><blockquote><ul><li>  服务器不支持实现请求所需要的功能，页眉值指定了未实现的配置。例如，客户发出了一个服务器不支持的 <strong>PUT</strong> 请求。</li><li>  解决 <strong>501</strong> 错误一般方法，这个错误在任何浏览器上都应是非常罕见的。 如果客户端不是一个浏览器则更有可能 – 特别是如果 <strong>Web</strong> 服务器很旧时。 在这两种情况下， 如果客户端指定了一个有效的请求类型， 那么 <strong>Web</strong> 服务器不是响应不正确，就是需要升级。</li></ul></blockquote><h4 id="502-Bad-Gateway-网关错误"><a href="#502-Bad-Gateway-网关错误" class="headerlink" title="502 Bad Gateway 网关错误"></a>502 <strong>Bad Gateway</strong> 网关错误</h4><blockquote><ul><li>服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 亦说 <strong>Web</strong> 服务器用作网关或代理服务器时收到了无效响应。<ul><li>  502.1 - CGI 应用程序超时。</li><li>  502.2 - CGI 应用程序出错。</li></ul></li></ul></blockquote><h4 id="503-Service-Unavailable-服务不可用"><a href="#503-Service-Unavailable-服务不可用" class="headerlink" title="503 Service Unavailable 服务不可用"></a>503 <strong>Service Unavailable</strong> 服务不可用</h4><blockquote><ul><li>  服务器由于维护或者负载过重未能应答。</li><li>  例如，<strong>Servlet</strong> 可能在数据库连接池已满的情况下返回 <strong>503</strong> 。服务器返回 <strong>503</strong> 时可以提供一个 <strong>Retry-After</strong> 头。这个错误代码为 <strong>IIS 6.0</strong> 所专用。</li></ul></blockquote><h4 id="504-Gateway-Timeout-网关超时"><a href="#504-Gateway-Timeout-网关超时" class="headerlink" title="504 Gateway Timeout 网关超时"></a>504 <strong>Gateway Timeout</strong> 网关超时</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。</li></ul></blockquote><h4 id="505-HTTP-Version-Not-Supported-HTTP-版本不支持"><a href="#505-HTTP-Version-Not-Supported-HTTP-版本不支持" class="headerlink" title="505 HTTP Version Not Supported HTTP 版本不支持"></a>505 <strong>HTTP Version Not Supported</strong> HTTP 版本不支持</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器不支持请求中所指明的 <strong>HTTP</strong> 版本。</li></ul></blockquote><h4 id="506-Variant-Also-Negotiates-变量也是导航"><a href="#506-Variant-Also-Negotiates-变量也是导航" class="headerlink" title="506 Variant Also Negotiates 变量也是导航"></a>506 <strong>Variant Also Negotiates</strong> 变量也是导航</h4><blockquote><ul><li>  对于请求是透明的内容导航导致循环参照。</li></ul></blockquote><h4 id="507-Insufficient-Storage-存储不足"><a href="#507-Insufficient-Storage-存储不足" class="headerlink" title="507 Insufficient Storage 存储不足"></a>507 <strong>Insufficient Storage</strong> 存储不足</h4><blockquote><ul><li>  服务器不能存储需要的内容去完成请求。</li></ul></blockquote><h4 id="508-Loop-Detected-返现环路"><a href="#508-Loop-Detected-返现环路" class="headerlink" title="508 Loop Detected 返现环路"></a>508 <strong>Loop Detected</strong> 返现环路</h4><blockquote><ul><li>  服务器发现了一个无限的循环档处理请求的时候。</li></ul></blockquote><h4 id="510-Not-Extended-未扩展"><a href="#510-Not-Extended-未扩展" class="headerlink" title="510 Not Extended 未扩展"></a>510 <strong>Not Extended</strong> 未扩展</h4><blockquote><ul><li>  请求中未满足访问资源的策略。服务器应该发回客户端发出扩展请求所需的所有信息。</li></ul></blockquote><h4 id="511-Network-Authentication-Required-需要网络授权"><a href="#511-Network-Authentication-Required-需要网络授权" class="headerlink" title="511 Network Authentication Required 需要网络授权"></a>511 <strong>Network Authentication Required</strong> 需要网络授权</h4><blockquote><ul><li>  客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。</li></ul></blockquote><h4 id="599-Network-Connect-Timeout-Error-网络连接超时异常-未知"><a href="#599-Network-Connect-Timeout-Error-网络连接超时异常-未知" class="headerlink" title="599 Network Connect Timeout Error 网络连接超时异常(未知)"></a>599 <strong>Network Connect Timeout Error</strong> 网络连接超时异常(未知)</h4><blockquote><ul><li>  这个状态码也没有在任何RFC中指定，但被某些 HTTP 代理用于向代理前面的客户端发送代理后面的网络连接超时信号。</li></ul></blockquote><hr><p>参考文献</p><ol><li> <a href="https://datatracker.ietf.org/doc/html/rfc7230">RCF7230</a></li><li> <a href="https://datatracker.ietf.org/doc/html/rfc7231">RCF7231</a></li><li> <a href="https://datatracker.ietf.org/doc/html/rfc7232">RCF7232</a></li></ol><hr>]]></content>
    
    
    <summary type="html">HTTP协议的状态码解释</summary>
    
    
    
    <category term="网络协议" scheme="https://www.onexstone.online/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="HTTP" scheme="https://www.onexstone.online/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.onexstone.online/posts/4a17b156/"/>
    <id>https://www.onexstone.online/posts/4a17b156/</id>
    <published>2021-09-26T01:02:21.941Z</published>
    <updated>2021-09-26T05:45:01.322Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深入剖析volatile关键字</title>
    <link href="https://www.onexstone.online/posts/369cb3ec/"/>
    <id>https://www.onexstone.online/posts/369cb3ec/</id>
    <published>2021-09-25T09:29:28.000Z</published>
    <updated>2021-09-26T07:08:11.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><blockquote><p>关键字 volatile 可以说是 Java 提供的最轻量级的同步机制，但由于它并不容易被正确、完整地理解，因此在笔者查阅了相关资料后，觉得有必要深入剖析一下在 JVM 层面上，对 volatile 型变量都做了哪些支持。</p></blockquote><span id="more"></span><h3 id="2-测试环境"><a href="#2-测试环境" class="headerlink" title="2. 测试环境"></a>2. 测试环境</h3><pre><code>- JDK：    - java version &quot;1.8.0_202&quot;    - Java(TM) SE Runtime Environment (build 1.8.0_202-b08)    - Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)- OS：Windows 10- IDE：    - IntelliJ IDEA 2021.1.3 (Ultimate Edition)    - Eclipse IDE , Version: Oxygen.3a Release (4.7.3a)- HSDIS plug-in :    - [Windows Version](https://github.com/doexit/hsdis.dll)</code></pre><hr><h3 id="3-volatile-的定义"><a href="#3-volatile-的定义" class="headerlink" title="3. volatile 的定义"></a>3. volatile 的定义</h3><ul><li>Java 语言规范（第三版）中对 volatile 的定义如下：<blockquote><p>Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致性的更新，线程应该确保通过排他锁单独获得这个变量。</p></blockquote></li></ul><hr><h3 id="4-volatile-型变量的特性"><a href="#4-volatile-型变量的特性" class="headerlink" title="4. volatile 型变量的特性"></a>4. volatile 型变量的特性</h3><ul><li>JMM （Java Memory Model, Java 内存模型）中对 volatile 变量定义的特殊规则：<ul><li>要求在工作内存中，每次使用 volatile 变量之前都必须先从主内存刷新最新的值，用于保证能看到其他线程对 volatile 变量所做的修改。</li><li>要求在工作内存中，每次修改 volatile 变量后都必须立刻同步回主内存，用于保证其他线程可以看到自己对 volatile 变量所做的修改。</li><li>要求被 volatile 修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。</li></ul></li><li>因此，当一个变量被定义成 volatile 之后，它将具有以下两个特性：<ul><li>保证此变量对所有线程的可见性；</li><li>禁止指令重排序优化（尤其指变量赋值操作的顺序）</li></ul></li></ul><hr><h3 id="5-语义解释"><a href="#5-语义解释" class="headerlink" title="5. 语义解释"></a>5. 语义解释</h3><ul><li><p>线程的可见性：</p><blockquote><p>一般指当一条线程修改了这个变量的值，新值对其他线程来说是可以立即得知的。</p></blockquote></li><li><p>JVM 中对该语义的支持</p><ul><li><p>使用双锁检测（DCL）实现的单例模式进行讲解，Java 源代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Singleton &#123;    private volatile static Singleton instance;    public static Singleton getInstance() &#123;        if (instance &#x3D;&#x3D; null) &#123;            synchronized (Singleton.class) &#123;                if (instance &#x3D;&#x3D; null) &#123;                    instance &#x3D; new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;    public static void main(String[] args) &#123;        Singleton.getInstance();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>其中，对 instance 变量赋值的部分转成汇编代码（此处使用的是 HSDIS 插件，该插件的作用是让 HostSpot 的 -XX:PrintAssembly 指令调用它来把即时编译器动态生成的本地代码还原成汇编代码输出），如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">0x00000000032061dc: movabs $0xd5ec0c38,%rax   ;   &#123;oop(a &#39;java&#x2F;lang&#x2F;Class&#39; &#x3D; &#39;com&#x2F;xxx&#x2F;JVMTest&#x2F;Singleton&#39;)&#125;0x00000000032061e6: mov    0x20(%rsp),%rsi0x00000000032061eb: mov    %rsi,%r100x00000000032061ee: mov    %r10d,0x68(%rax)0x00000000032061f2: shr    $0x9,%rax0x00000000032061f6: movabs $0x120b4000,%rsi0x0000000003206200: movb   $0x0,(%rax,%rsi,1)0x0000000003206204: lock addl $0x0,(%rsp)     ;*putstatic instance                                            ; - com.xxx.JVMTest.Singleton::getInstance@24 (line 17)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>通过对比 volatile 添加前后的汇编代码可以发现，有 volatile 变量修饰的共享变量进行写操作的时候会多执行一个 “lock addl $0x0,(%rsp)” 操作，这个操作的作用相当于一个内存屏障。</p></li><li><p>通过查询 IA32 手册可知，lock 前缀的指令在多核处理器下会引发两件事情：</p><ul><li>将当前处理器缓存行的数据写回到系统内存；</li><li>该写入动作会使其他处理器或者内核中缓存了该内存地址的数据无效化。</li></ul></li><li><p>因此，通过这样一个空操作（addl $0x0,(%rsp)，把RSP寄存器的值加0），就可以让前面 volatile 变量的修改对其他处理器立即可见。同时，因为 lock 指令的本质是对 volatile 变量立即进行 “store” 和 “write” 操作，即该指令依赖于之前对 volatile 变量的其他操作，进而使得处理器不会对 lock 指令进行重排序到 volatile 其他指令之前，也就达到了“指令重排序无法越过内存屏障”的效果。</p></li></ul><hr><h3 id="6-理解误区"><a href="#6-理解误区" class="headerlink" title="6. 理解误区"></a>6. 理解误区</h3><ul><li><p><strong>基于 volatile 变量的运算在并发下是线程安全的。 (×)</strong></p></li><li><p>下面，笔者用一个 volatile 变量自增的例子来说明这个问题</p>  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class VolatileTest &#123;    public static volatile int count &#x3D; 0;    public static void increase() &#123;        count++;    &#125;    private static final int THREADS_COUNT &#x3D; 20;    public static void main(String[] args) &#123;        Thread[] threads &#x3D; new Thread[THREADS_COUNT];        for (int i &#x3D; 0; i &lt; THREADS_COUNT; i++) &#123;            threads[i] &#x3D; new Thread(new Runnable() &#123;                @Override                public void run() &#123;                    for (int i &#x3D; 0; i &lt; 100; i++) &#123;                        increase();                    &#125;                &#125;            &#125;);            threads[i].start();        &#125;        &#x2F;&#x2F; 等待所有累加线程都结束        while (Thread.activeCount() &gt; 1) &#123;            Thread.yield();        &#125;        System.out.println(count);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行演示<br><img src="https://oscimg.oschina.net/oscnet/up-847fae85f848d492abb003083a403ac0556.gif" alt="VolatileTest执行演示" loading="lazy"><em>VolatileTest执行演示</em></p></li><li><p>这段代码的作用是建立了 20 个线程，每个线程对 count 变量进行 100 次自增操作。理论上，在所有线程并发正确的情况下，最后输出的结果应该是 2000 。但通过多次的实际运行可以发现，每次输出的结果都不一样，甚至是一个小于 2000 的数字。</p></li><li><p>使用 javap 命令对 VolatileTest 进行反编译的代码如下：</p>  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void increase();    Code:    0: getstatic     #2                  &#x2F;&#x2F; Field count:I    3: iconst_1    4: iadd    5: putstatic     #2                  &#x2F;&#x2F; Field count:I    8: return    LineNumberTable:    line 15: 0    line 16: 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从字节码层面我们可以很容易的发现问题的所在，当 getstatic 指令把 count 的值取到操作栈顶时， volatile 关键字保证了 count 的值在此时是正确的，但在执行 iconst_1 、iadd 这些指令（非原子操作）的时候，其他线程可能已经把 count 的值改变了，而操作栈顶的值就变成了过期的数据，所以 putstatic 指令执行后就可能把较小的 count 值同步回主内存中。</p></li></ul><hr><h3 id="7-使用场景"><a href="#7-使用场景" class="headerlink" title="7. 使用场景"></a>7. 使用场景</h3><ul><li>通过上面的例子我们应该清楚，由于 volatile 变量只保证可见性，在不符合以下两条规则的运算场景中，我们依然需要通过加锁（使用 synchronized、java.util.concurrent 中的锁或原子类）来保证原子性：<ul><li>运算结果并不依赖变量的当前值（无后效性），或者能够确保只有单一的线程修改变量的值；</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul></li></ul><hr><h3 id="8-参考文献"><a href="#8-参考文献" class="headerlink" title="8. 参考文献"></a>8. 参考文献</h3><pre><code>1. 方腾飞, 魏鹏, 程晓明．Java并发编程的艺术 [M]. 北京：机械工业出版社，2015：8-11.2. 周志明．深入理解Java虚拟机: JVM高级特性与最佳实践（3 版）[M]. 北京：机械工业出版社，2019：444-450.</code></pre>]]></content>
    
    
    <summary type="html">Java 并发底层原理的支持</summary>
    
    
    
    <category term="Java" scheme="https://www.onexstone.online/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.onexstone.online/tags/Java/"/>
    
    <category term="JVM" scheme="https://www.onexstone.online/tags/JVM/"/>
    
  </entry>
  
</feed>
