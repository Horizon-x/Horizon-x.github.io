<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ONESTONE Blogs</title>
  <icon>https://www.onexstone.online/icon.png</icon>
  <subtitle>Youth means limitless possibilities</subtitle>
  <link href="https://www.onexstone.online/atom.xml" rel="self"/>
  
  <link href="https://www.onexstone.online/"/>
  <updated>2021-10-02T10:00:26.035Z</updated>
  <id>https://www.onexstone.online/</id>
  
  <author>
    <name>ONESTONE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HotSpot对synchronized的锁优化策略</title>
    <link href="https://www.onexstone.online/posts/fa978b73/"/>
    <id>https://www.onexstone.online/posts/fa978b73/</id>
    <published>2021-10-02T09:34:53.000Z</published>
    <updated>2021-10-02T10:00:26.035Z</updated>
    
    <content type="html"><![CDATA[<!--文章摘要部分--><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>凡是有过 Java 并发编程经验的都应该了解在 JDK 6 及以后中对锁一共有四种状态的描述，分别是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这些都是 HotSpot 虚拟机对 synchronized 实现的锁机制做的进一步优化。正好笔者最近在翻阅相关的资料，因此觉得有必要记录一下有关 synchronized 的锁优化相关问题。<span id="more"></span><!--文章正文部分--></li></ul><h3 id="Java-对象头存储结构"><a href="#Java-对象头存储结构" class="headerlink" title="Java 对象头存储结构"></a>Java 对象头存储结构</h3><ul><li>在 Java 中，绝大部分的锁信息都是存储于对象头信息中，因此我们需要先对 Java 对象头的存储结构进行分析，以便更好地了解各种锁的实现原理。</li></ul><ol><li>在 HotSpot 虚拟机中，非数组对象头主要由两部分组成（如果是数组对象则为三部分），分别是存储对象的运行时数据，如哈希码、GC 分代年龄、锁信息等，这部分也被官方称为 <code>Mark Word</code>；另一部分则是存储指向方法区对象类型数据的指针；（如果是数组对象则有第三部分用于存储数组的长度），具体的结构如下表所示：</li></ol><p><img src="https://oscimg.oschina.net/oscnet/up-b0a8f655de500fa0e05fc032bb6a745f44c.png" alt="Java 对象头存储结构" loading="lazy"><em>表1 Java 对象头存储结构</em></p><blockquote><ul><li>HotSpot 虚拟机中使用 2 字宽存储非数组对象的对象头信息，使用 3 子宽存储数组对象的对象头信息；</li><li>在 32 位 JVM 中，1 字宽等于 4 字节，1 字节等于 8 位，即 32 位；</li><li>在 64 位 JVM 中，1 字宽等于 8 字节，1 字节等于 8 位，即 64 位；</li></ul></blockquote><h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><ul><li>根据上述分析我们可以看到与锁相关的信息都会被 JVM 存储在 <code>Mark Word</code> 中。</li></ul><ol><li>由于对象头存储的是与对象自身定义数据无关的额外信息，因此 HotSpot 官方为了进一步提高 JVM 的空间使用效率，把 <code>Mark Word</code> 部分设计成了 <strong>非固定的数据结构</strong>，即其中的数据结构会随着对象状态的变化而有所不同，以便在极小的空间中存储尽可能多的信息。</li><li>HotSpot 官方在 <a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/markOop.hpp">markOop.hpp</a> 中对 <code>Mark Word</code> 的存储结构描述如下：</li></ol><pre class="line-numbers language-hpp" data-language="hpp"><code class="language-hpp">&#x2F;&#x2F; The markOop describes the header of an object.&#x2F;&#x2F;&#x2F;&#x2F; Note that the mark is not a real oop but just a word.&#x2F;&#x2F; It is placed in the oop hierarchy for historical reasons.&#x2F;&#x2F;&#x2F;&#x2F; Bit-format of an object header (most significant first, big endian layout below):&#x2F;&#x2F;&#x2F;&#x2F;  32 bits:&#x2F;&#x2F;  --------&#x2F;&#x2F;             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)&#x2F;&#x2F;             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)&#x2F;&#x2F;             size:32 ------------------------------------------&gt;| (CMS free block)&#x2F;&#x2F;             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)&#x2F;&#x2F;&#x2F;&#x2F;  64 bits:&#x2F;&#x2F;  --------&#x2F;&#x2F;  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)&#x2F;&#x2F;  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)&#x2F;&#x2F;  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)&#x2F;&#x2F;  size:64 -----------------------------------------------------&gt;| (CMS free block)&#x2F;&#x2F;&#x2F;&#x2F;  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)&#x2F;&#x2F;  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)&#x2F;&#x2F;  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)&#x2F;&#x2F;  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)&#x2F;&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>由此可以得知，<code>Mark Word</code> 的存储结构主要是会随着对象的锁状态的变化而变化，对应的四种锁状态如下两表所示：</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-acb21bcef91338761f89f308b969f7f55b5.png" alt="32 位 HotSpot 虚拟机对象头的 Mark Word 结构" loading="lazy"><em>表2  32 位 HotSpot 虚拟机对象头的 Mark Word 结构</em></p><p><img src="https://oscimg.oschina.net/oscnet/up-3faf976288002b69d07739eca003ee00b5a.png" alt="64 位 HotSpot 虚拟机对象头的 Mark Word 结构" loading="lazy"><em>表3   64 位 HotSpot 虚拟机对象头的 Mark Word 结构</em></p><blockquote><p>为了行文方便，本文余下的分析均是基于 32 位 HotSpot 虚拟机进行分析。</p></blockquote><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><ul><li>未优化前的 synchronized 同步语义。</li><li>synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，这就是为什么Synchronized效率低的原因。（如果对 synchronized 的底层原理不太了解，可以先阅读笔者的另一篇文章：<a href="https://my.oschina.net/onexstone/blog/5272662">Java中保证线程安全的三板斧</a>）</li><li>因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “重量级锁”。</li></ul><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul><li>提升性能的依据（经验法则）：对于绝大部分的锁，在整个同步期间都是不存在竞争的。</li><li>本质：通过在无竞争的情况下使用 CAS 操作去消除互斥同步使用的互斥量。</li><li>轻量级锁的获取锁与释放锁的流程图如下所示：</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-414b524aabfc30650be11c7cb61aa6d967b.jpg" alt="轻量级锁的加锁与释放锁的流程图" loading="lazy"><em>图1 轻量级锁的加锁与释放锁的流程图</em></p><h4 id="无锁-gt-轻量级锁"><a href="#无锁-gt-轻量级锁" class="headerlink" title="无锁 -&gt; 轻量级锁"></a>无锁 -&gt; 轻量级锁</h4><p><img src="https://oscimg.oschina.net/oscnet/up-ed9de5433763789cda52a477b74e266716f.jpg" alt="无锁状态时的栈帧与对象状态" loading="lazy"><em>图2 无锁状态时的栈帧与对象状态</em></p><ol><li>若对象的 <code>Mark Word</code> 的锁标志位为 01 （偏向标志位为 0 ），即无锁状态时，虚拟机首先会在当前线程的栈帧中创建一个名为 “锁记录”（Lock Record） 的空间，专门用于存放当前待锁对象的 <code>Mark Word</code> 的副本（Displaced Mark Word）；</li><li>虚拟机将使用 CAS 的方式尝试把当前对象 <code>Mark Word</code> 中的前 29 bit 更新为指向 “锁记录” 的指针；</li><li>若上述操作更新成功，则当前线程成功拥有该对象的锁，并且把对应的锁标志位置为 00，表示此时该对象处于轻量级锁状态；</li><li>若操作执行失败，则说明目前有其他线程在竞争获取该对象的锁，此时，虚拟机会先去检查当前对象的 <code>Mark Word</code> 是否指向当前待获取锁的线程的栈帧，如果是，则说明该线程已经获取了该对象的锁，直接进入同步块继续执行；</li><li>如果当前对象的 <code>Mark Word</code> 不是指向当前线程的栈帧，则说明目前有其他线程已经获得了该对象的锁，<strong>若出现两条以上的线程同时竞争同一个锁时，轻量级锁会失效，直接膨胀成重量级锁，后面等待的线程会进入阻塞状态。</strong></li></ol><h4 id="轻量级锁-gt-无锁"><a href="#轻量级锁-gt-无锁" class="headerlink" title="轻量级锁 -&gt; 无锁"></a>轻量级锁 -&gt; 无锁</h4><p><img src="https://oscimg.oschina.net/oscnet/up-1436d3a82486bc4f5927ee59a70628508ea.jpg" alt="轻量级锁状态时的栈帧与对象状态" loading="lazy"><em>图3 轻量级锁状态时的栈帧与对象状态</em></p><ol><li>仍然采用 CAS 操作，尝试把锁记录空间保存的对象的 <code>Mark Word</code> 的副本替换回对象的 <code>Mark Word</code> 的位置上；</li><li>如果替换成功，那么说明执行同步的过程中没有产生竞争，对象的锁随即被释放，锁标志位被置为 01；</li><li>如果替换失败，说明有其他线程尝试获取过该对象的锁，那么在释放锁之后要唤醒被阻塞挂起的其他线程。</li></ol><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul><li>提升性能的依据（经验法则）：对于绝大部分的锁，在整个同步期间都是不存在竞争的，而且总是由同一个线程多次获得。</li><li>本质：通过在无竞争的情况下把整个同步操作都消除。</li><li>偏向锁的“偏”，主要含义是：对象的锁会偏向于第一次获取该锁的线程，若之后一直没有出现竞争情况，那么之后该线程在执行到对应的同步块时将不再执行任何同步操作（包括加锁、解锁、<code>Mark Word</code> 的更新等）。</li></ul><blockquote><p>自 JDK 6 起，HotSpot 虚拟机将默认启动偏向锁，对应的 JVM 启动参数为：-XX:+UseBiasedLocking；<br>虽然是默认启动的但更准确地说它是在应用程序启动几秒钟之后才激活，如果想要关闭延迟，可以把 JVM 的启动参数：-XX:BiasedLockingStartupDelay设置为 0。</p></blockquote><h4 id="无锁-gt-偏向锁"><a href="#无锁-gt-偏向锁" class="headerlink" title="无锁 -&gt; 偏向锁"></a>无锁 -&gt; 偏向锁</h4><ol><li>当对象的锁被第一次获取时，会把锁标志位置为 01，偏向模式标志位置为 1 ，同时使用 CAS 操作把该线程的ID记录至对象头的 <code>Mark Word</code> 中；</li><li>如果上述 CAS 操作成功，那么对象进入偏向锁状态，接下来再次执行同步块代码时将不再执行任何同步操作；</li></ol><h4 id="偏向锁-gt-无锁-轻量级锁"><a href="#偏向锁-gt-无锁-轻量级锁" class="headerlink" title="偏向锁 -&gt; 无锁 / 轻量级锁"></a>偏向锁 -&gt; 无锁 / 轻量级锁</h4><ol><li>一旦出现其他线程尝试获取处于偏向锁状态的对象时，偏向模式马上结束；</li><li>根据当前被锁定的状态决定是否撤销偏向模式，如果撤销，则会把锁标志位恢复至无锁状态（01），或者轻量级锁状态（00）。</li></ol><h4 id="偏向锁的局限性"><a href="#偏向锁的局限性" class="headerlink" title="偏向锁的局限性"></a>偏向锁的局限性</h4><ul><li>通过前一节的分析我们可以发现，偏向锁的验证是通过记录在 <code>Mark Word</code> 的线程ID 实现的，<del>但是有一个细节，不知道大家有没发现。</del> <strong>线程ID 存储的位置刚好是存储对象哈希码的位置</strong>，而在 Java 中规定，如果一个对象计算过哈希码，那么理论上应该一直保持不变 <del>（实际上也可以通过重载 hashCode() 方法去改变计算哈希码的方式，返回自定义的哈希码）</del>，否则很多依赖对象哈希码的 API 都可能存在出错的风险。同时，作为绝大部分对象哈希码来源的 Object::hashCode() 方法返回的是一致性哈希码，这个值自第一次计算以后被存储至对象头的 <code>Mark Word</code> 中，理应永不改变。</li><li>因此，当一个对象计算过哈希码之后，就再也不能进入偏向锁状态；</li><li>同时，当一个对象正处于偏向锁状态时，又需要计算哈希码，那么它的偏向锁会直接膨胀成重量级锁。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>各种锁状态之间的转换及对应的MarkWord状态图</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-167e465fde230a8263bbdab7c5f58a1361f.jpg" alt="锁状态的转换及对应的MarkWord状态" loading="lazy"><em>图4 锁状态的转换及对应的MarkWord状态</em></p><ul><li>三种锁机制的优劣对比</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-a3abf82e7c1285060264a8a692cdc86c58e.png" alt="三种锁机制的优劣对比" loading="lazy"><em>表4   三种锁机制的优劣对比</em></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li>方腾飞, 魏鹏, 程晓明．Java并发编程的艺术 [M]. 北京：机械工业出版社，2015：11-16.</li><li>周志明．深入理解Java虚拟机: JVM高级特性与最佳实践（3 版）[M]. 北京：机械工业出版社，2019：479-485.</li></ol><blockquote><p>文章本天成，妙手偶得之。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">synchronized 底层实现的各种锁之间的转换及优化</summary>
    
    
    
    <category term="Java" scheme="https://www.onexstone.online/categories/Java/"/>
    
    <category term="Java并发编程" scheme="https://www.onexstone.online/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JVM" scheme="https://www.onexstone.online/tags/JVM/"/>
    
    <category term="Java" scheme="https://www.onexstone.online/tags/Java/"/>
    
    <category term="锁优化策略" scheme="https://www.onexstone.online/tags/%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java中保证线程安全的三板斧</title>
    <link href="https://www.onexstone.online/posts/cf2f473d/"/>
    <id>https://www.onexstone.online/posts/cf2f473d/</id>
    <published>2021-10-01T12:59:31.000Z</published>
    <updated>2021-10-02T09:57:53.097Z</updated>
    
    <content type="html"><![CDATA[<!--文章摘要部分--><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>现在，如果要使用 Java 实现一段线程安全的代码，大致有 synchronized 、 java.util.concurrent 包等手段。虽然大家都会用，但却不一定真正清楚其在 JVM 层面上的实现原理，因此，笔者在查阅了一些资料后，希望把自己对此的一些见解分享给大家。</p><span id="more"></span><!--文章正文部分--><h3 id="三板斧之一：互斥同步"><a href="#三板斧之一：互斥同步" class="headerlink" title="三板斧之一：互斥同步"></a>三板斧之一：互斥同步</h3><ul><li>互斥同步：使用互斥的手段来保证同步操作。互斥是方法，同步是目的。</li><li>在 Java 的世界里，最基本的互斥同步手段就是使用 synchronized 关键字。</li></ul><h4 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h4><ol><li><p>synchronized 能实现同步的理论基础是：Java 中的每一个对象都可以作为锁。</p></li><li><p>synchronized 关键字在不同的使用场景下，作为锁的对象有所不同，主要分为以下三种情况：</p><ul><li>对于同步代码块，锁就是声明 synchronized 同步块时指定的对象（synchronized 括号中配置的对象）；</li><li>对于普通对象方法，锁就是当前的实例对象；</li><li>对于静态同步块，锁就是当前类的 Class 对象。</li></ul></li><li><p>我们可以通过一段代码来进一步说明 synchronized 是如何实现互斥同步的。</p></li></ol><ul><li><p>示例代码</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class SynchronizedTest &#123;    public void test() &#123;        synchronized (this) &#123;            try &#123;                System.out.println(&quot;SynchronizedTest.test() method start!&quot;);            &#125; catch (Exception e) &#123;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对上述代码生成的字节码使用 Javap 进行反编译，结果如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Compiled from &quot;SynchronizedTest.java&quot;public class com.xxx.JVMTest.SynchronizedTest &#123;  public com.xxx.JVMTest.SynchronizedTest();    Code:       0: aload_0       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V       4: return  public void test();    Code:       0: aload_0       1: dup       2: astore_1       3: monitorenter       4: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;       7: ldc           #3                  &#x2F;&#x2F; String SynchronizedTest.test() method start!       9: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V      12: aload_1      13: monitorexit      14: goto          22      17: astore_2      18: aload_1      19: monitorexit      20: aload_2      21: athrow      22: return    Exception table:       from    to  target type           4    14    17   any          17    20    17   any&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在图中我们可以看到反编译的代码中，存在两个由 Javac 编译器加入的指令，分别是插入到同步代码块开始位置的 monitorenter 指令和插入到同步代码块结束位置以及异常处的 monitorexit 指令。</p></li><li><p>根据《Java 虚拟机规范》可知，每个 Java 对象都有一个监视器锁（monitor）。在执行 monitorenter 指令时，首先要去尝试获取对象的锁，如果这个对象没被锁定，或者当前线程已经持有了该对象的锁，就把锁的计数器的值加一，而在执行 monitorexit 指令时会将锁计数器的值减一。一旦锁计数器的值为零，锁随即被释放。如果其他线程已经占用了该对象的锁，则该线程进入阻塞状态，直到锁的计数器为零时，再重新尝试获取该对象的所有权。</p></li><li><p>因此，<strong>本质上 JVM 就是通过进入 Monitor 对象（monitorenter）以及退出 Monitor 对象（monitorexit）来实现方法和代码块的同步操作。</strong></p></li></ul><ol start="4"><li>通过对 monitorenter 指令和 monitorexit 指令的分析，我们可以推出 synchronized 的三条结论：</li></ol><ul><li>被 synchronized 声明的同步代码块对同一线程而言是可重入的，所以同一线程重复进入同步块也不会出现被自己锁死的情况；</li><li>被 synchronized 声明的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。因此无法实现对已经获得锁的线程强制释放锁的操作，以及对等待锁的线程实现中断等待或超时退出的机制。</li><li>由于 Java 线程是映射到操作系统的原生内核线程之上的，如果要阻塞或者唤醒一条线程，则需要操作系统来帮忙完成，这不可避免地陷入用户态到核心态的转变之中，因此在一些经典的 Java 并发编程资料中，synchronized 被形象地称为重量级锁。但它相对于利用 java.util.concurrent 包中 Lock 接口实现的锁机制仍有一个先天的优势，就是 synchronized 的锁信息是被 JVM 记录在线程和对象的元数据中的，可以很轻易的知道当前哪些锁对象是被哪些特定的线程所持有，从而更容易进行锁优化。</li></ul><ol start="5"><li>在这里需要补充一点的就是，同步方法虽然也可以使用 monitorenter 指令和 monitorexit 指令实现同步操作，但实际上目前的实现中并没有采用这种方案</li></ol><ul><li><p>我们可以具体分析下面的代码</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class SynchronizedTest &#123;    public synchronized void testTwo() &#123;        System.out.println(&quot;SynchronizedTest.testTwo() method start!&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对上述代码生成的字节码使用 Javap 进行反编译，结果如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public synchronized void testTwo();  descriptor: ()V  flags: ACC_PUBLIC, ACC_SYNCHRONIZED  Code:    stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1       0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;       3: ldc           #6                  &#x2F;&#x2F; String SynchronizedTest.testTwo() method start!       5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V       8: return    LineNumberTable:      line 23: 0      line 24: 8    LocalVariableTable:      Start  Length  Slot  Name   Signature          0       9     0  this   Lcom&#x2F;xxx&#x2F;JVMTest&#x2F;SynchronizedTest;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从反编译的结果来看，方法的同步并没有通过指令 monitorenter 和 monitorexit 来完成。相对于普通方法，其常量池中多了 ACC_SYNCHRONIZED 标示符。实质上 JVM 是根据该标示符来实现方法的同步的，当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取 Monitor 锁，获取成功之后才去执行方法体，并在方法执行完后释放 Monitor 锁。同时，在方法执行期间，其他任何线程都无法再获得同一个 Monitor 锁对象。</p></li><li><p>方法的同步和代码块的同步没有本质区别，只是其用一种隐式的方式来实现，无需通过字节码来完成。</p></li></ul><h3 id="三板斧之二：非阻塞同步"><a href="#三板斧之二：非阻塞同步" class="headerlink" title="三板斧之二：非阻塞同步"></a>三板斧之二：非阻塞同步</h3><ul><li>根据上一小节我们可以知道，在进行互斥同步时，无论共享的数据是否真的存在竞争，它都会进行加锁操作，从而导致用户态与核心态的转换、维护锁计数器以及检查是否有等待锁的线程需要被唤醒等额外开销，因此互斥同步属于一种悲观的并发策略。</li><li>那么是否存在一种乐观的并发策略呢？答案是有的，目前在 Java 中实现了一种基于冲突检测的加锁策略 ———— CAS 操作。</li><li>通俗的说就是先不管是否存在竞争，先进行操作，一旦产生了冲突，再通过其他补偿手段进行修正。最常见的就是通过不断地重试，直到没有竞争为止。</li><li>这种策略地好处在于全程是处于用户态中进行操作，从而避免了频繁地用户态与核心态之间的切换操作。</li></ul><ol><li>直到 JDK 5 ，在 java.util.concurrent.atomic 包中才提供了一些类支持原子级别的 CAS 操作，包括 AtomicBoolean、AtomicInteger、AtomicLong 等，而这些类的方法大多数又是调用的 sun.misc.Unsafe 类里面的 compareAndSwapInt() 和 compareAndSwapLong() 等几个保证原子操作的方法。</li></ol><ul><li><p>以 java.util.concurrent.atomic.AtomicInteger 类的 getAndIncrement() 方法为例：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class AtomicInteger extends Number implements java.io.Serializable &#123;    static &#123;        try &#123;            &#x2F;&#x2F;获取 value 变量的偏移量, 赋值给 valueOffset            valueOffset &#x3D; unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;    &#125;    &#x2F;**     * Atomically increments by one the current value.     *     * @return the previous value     *&#x2F;    public final int getAndIncrement() &#123;        return unsafe.getAndAddInt(this, valueOffset, 1);    &#125;    ...other methods...&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;public final class Unsafe &#123;    public final int getAndAddInt(Object var1, long var2, int var4) &#123;        int var5;        do &#123;            &#x2F;&#x2F;通过对象和偏移量获取变量的值        &#x2F;&#x2F;由于 volatile 的修饰, 因此所有线程看到的 var5 都是一样的            var5 &#x3D; this.getIntVolatile(var1, var2);        &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));        return var5;    &#125;    ...other methods...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>我们可以看到 Unsafe 类的 getAndAddInt() 方法中存在一个 do while 循环，而循环条件中的 compareAndSwapInt() 方法会以原子的方式尝试修改 var5 的值。 </p></li><li><p>具体而言，该方法通过 obj 和 valueOffset 获取变量的值，如果这个值和 var5 不一样，说明其他线程已经先一步修改了 obj + valueOffset 地址处的值，此时 compareAndSwapInt() 返回 false，继续循环；如果这个值和 var5 一样，说明没有其他线程修改 obj + valueOffset 地址处的值，此时可以将 obj + valueOffset 地址处的值改为 var5 + var4 ，compareAndSwapInt() 返回 true，退出循环。由于 compareAndSwapInt() 方法是原子操作, 所以compareAndSwapInt() 修改 obj + valueOffset 地址处的值时不会被其他线程中断。</p></li></ul><ol start="2"><li>通过上面的例子我们可以发现，使用 CAS 来实现同步操作也引发了一些新的问题：</li></ol><ul><li>如果自旋 CAS 长时间不成功，就会白白浪费本来就宝贵的 CPU 时间；</li><li>理论上而言，CAS 也只能保证一个共享变量的原子操作，功能上并没有 synchronized 同步代码块丰富；</li><li>ABA问题：我们可以假设这样一种场景，如果一个值原来是A，变成了B，之后又变回了A，那么在使用 CAS 操作进行检查时会出现以为它的值没有发生变化，而实际上已经变化了的情况。不过实际上即使出现了 ABA 问题在大部分并发情况下也不会影响程序的并发正确性，如果证实确实存在影响，那么最好改用 synchronized 同步代码块来实现同步操作。</li></ul><h3 id="三板斧之三：无同步线程安全"><a href="#三板斧之三：无同步线程安全" class="headerlink" title="三板斧之三：无同步线程安全"></a>三板斧之三：无同步线程安全</h3><ul><li>其实，同步与否与是否线程安全没有必然联系，同步只是实现线程安全的一种手段，如果存在有竞争的共享数据那么使用同步手段来保证线程安全也不失为一种好的方案，但如果本来就不存在竞争的可能，那它本身就有隐式的线程安全保证。</li></ul><ol><li><p>可重入代码（纯代码）</p><blockquote><p>是一种允许多个进程同时访问的代码。程序在运行过程中可以被打断，并由开始处再次执行，并且在合理的范围内（多次重入，而不造成堆栈溢出等其他问题），程序可以在被打断处继续执行，且执行结果不受影响。（<a href="https://baike.baidu.com/item/%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A3%E7%A0%81/1955592?fr=aladdin">可重入代码 | 百度百科</a>）</p></blockquote></li><li><p>可重入代码拥有一些共同的特征：</p></li></ol><ul><li>不依赖全局变量；</li><li>不依赖存储在堆上的数据和公用的系统资源；</li><li>使用到的状态量都由参数传入；</li><li>不调用其他非可重入的方法；<br>……</li></ul><ol start="3"><li><p>因此，如果一段代码中存在与其他代码的共享变量，只要能保证这些变量的可见范围只在同一个线程内，那么无需同步也能保证线程之间的数据安全性。</p></li><li><p>在 Java 中，使用了 java.lang.ThreadLocal 类来实现线程本地存储的功能，每个线程的 Thread 对象中都有一个 ThreadLocalMap 对象，这个对象存储了一组以 ThreadLocal.threadLocalHashCode 为键，以本地线程变量为值的 K - v 键值对。由于每个线程的 ThreadLocal.threadLocalHashCode 的值都是独一无二的，因此所映射的值也只能该线程自己才能访问到，也就实现了线程安全。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>可以使用互斥同步（阻塞同步）的方式，实现共享变量的线程安全，典型例子包括：synchronized 等;</li><li>可以使用自旋 CAS 的方式，实现共享变量的线程安全，典型例子包括：sun.misc.Unsafe 类、java.util.concurrent.atomic 包中的 AtomicBoolean、AtomicInteger、AtomicLong 等；</li><li>如果可以保证共享变量的可见范围均在同一个线程之内，那么其本身就带有隐式的线程安全性，不需要再做其他显式的同步操作。</li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li>方腾飞, 魏鹏, 程晓明．Java并发编程的艺术 [M]. 北京：机械工业出版社，2015：11-20.</li><li>周志明．深入理解Java虚拟机: JVM高级特性与最佳实践（3 版）[M]. 北京：机械工业出版社，2019：471-478.</li></ol><blockquote><p>读书不觉已春深，一寸光阴一寸金。</p></blockquote>]]></content>
    
    
    <summary type="html">详细阐述Java中保证线程安全的三套策略</summary>
    
    
    
    <category term="Java" scheme="https://www.onexstone.online/categories/Java/"/>
    
    <category term="Java并发编程" scheme="https://www.onexstone.online/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JVM" scheme="https://www.onexstone.online/tags/JVM/"/>
    
    <category term="Java" scheme="https://www.onexstone.online/tags/Java/"/>
    
    <category term="线程安全" scheme="https://www.onexstone.online/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个属于自己的小站</title>
    <link href="https://www.onexstone.online/posts/e0afdf66/"/>
    <id>https://www.onexstone.online/posts/e0afdf66/</id>
    <published>2021-09-30T08:21:04.000Z</published>
    <updated>2021-10-01T06:43:23.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我自从开始学习编程技术以来，一直想拥有一个属于自己的网站，不仅是想对自己技术的沉淀，更重要的是希望能找到一个自由撰写文章，分享自己新想法的平台。</p><span id="more"></span><p>OK，言归正传，既然是从零开始，那笔者本着负责任的态度，会尽可能的使用图文并茂的方式进行演示，但这毕竟是一篇新手向的文章，因此，对于内部实现原理等之类的细节，本文不会展开过多阐述。</p><h2 id="使用到的工具"><a href="#使用到的工具" class="headerlink" title="使用到的工具"></a>使用到的工具</h2><ul><li>Node.js &amp; npm</li><li>git</li><li>gitHub or Coding</li><li>Hexo，本文主要是基于 Hexo 的博客框架来搭建个人的网站</li></ul><h2 id="行文约定"><a href="#行文约定" class="headerlink" title="行文约定"></a>行文约定</h2><p>笔者建议在正式开始实操之前，一定先看完本篇文章，笔者在第一次操作也是因为跳过了一些步骤，导致出现了各种莫名其妙的错误。</p><blockquote><p>注释处多为相关补充说明，对正常流程没有影响，若没有兴趣，可以略过。</p></blockquote><p>与文章相关疑问都可在评论区中留言，或者 <a href="https://www.onexstone.online/">笔者的个人博客</a> 下进行评论。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><blockquote><p>如果读者对 Node.js 第一次听说，可以先到 <a href="https://nodejs.org/zh-cn/about/">Node.js 官网</a> 中大致了解一下，因为本文只涉及其中最基本的几条命令，因此即使不了解原理也不影响其正常使用。</p></blockquote><h4 id="如何安装-Node-js"><a href="#如何安装-Node-js" class="headerlink" title="如何安装 Node.js"></a>如何安装 Node.js</h4><ul><li><a href="https://nodejs.org/zh-cn/">Node.js 下载地址</a></li><li>建议下载长期维护版而非最新尝鲜版（因为如果是最新发布的版本，有些新功能可能会存在不可预知的 bug）</li></ul><ol><li>从官网直接下载的是一个 *.msi 的文件，下载直接就可直接双击运行；</li><li>根据安装向导按照默认配置一路 next 即可；</li><li>安装成功，文件夹结构如下，并在上面安装过程中已自动配置了环境变量和安装好了npm包；</li><li>此时可以在 windows 的命令行提示符 或者 MacOS 的终端中执行 <code>node -v</code> 和 <code>npm -v</code> ，如果能查看到 node 和 npm 的版本号，则说明安装成功；<blockquote><p>注：npm 是随 Node.js 一起被安装的包管理工具，你可以理解成 Node.js 自带的应用商店。</p></blockquote></li></ol><p><img src="https://oscimg.oschina.net/oscnet/up-49436ab102fa051ca47da3519a8035bef10.png" alt="npm安装成功验证图" loading="lazy"><em>图1 npm安装成功验证图</em></p><ol start="5"><li>注意，因为 Node.js 默认是使用国外的仓库下载导入的模块，因此建议先把 npm 对应的下载源切换成淘宝镜像源：<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;&#x2F; 切换之后可以输入以下命令检查是否切换成功：npm get registry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>如果切换成功将会输出下面的提示信息：</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-1030e217ac5258f5ced4f3a2ad4c190eb48.png" alt="npm切换淘宝镜像源" loading="lazy"><em>图2 npm切换淘宝镜像源</em></p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><blockquote><ul><li><a href="https://git-scm.com/about">Git</a> 是一个开源的分布式版本控制系统，由 Linus Torvalds（同时也是 Linux 的作者）为了管理 Linux 开发而开发。</li><li>简而言之，是一个版本管理工具。譬如设计师设计好了第三版的海报，客户却说还是要第一版吧，这时便可以通过 Git 快速回退到最初的版本。</li><li>你只需要把每次更改的状态（Git 会自动进行检测，你只要掌握基础的几条命令就可以了）告诉 Git，而不需要每个版本都保存一份压缩包，既方便也能大大节约空间。</li><li>当然这主要只对代码文本起作用，因为 Git 的本质是记录各行代码的增减，倘若是像视频、海报这类二进制文件来说便体现不出丝毫优势了。当然想要应对这种场景还有 <a href="https://git-lfs.github.com/">Git LFS</a>。</li></ul></blockquote><h4 id="如何安装-Git-工具"><a href="#如何安装-Git-工具" class="headerlink" title="如何安装 Git 工具"></a>如何安装 Git 工具</h4><ol><li>到 <a href="https://git-scm.com/">Git 官网</a> 下载对应的版本，下载下来是一个 *.exe 的可执行文件，双击运行即可；</li><li>限于篇幅，具体的安装设置可以参考网上教程，笔者在此就不展开赘述了。</li></ol><h3 id="注册-GitHub"><a href="#注册-GitHub" class="headerlink" title="注册 GitHub"></a>注册 GitHub</h3><ul><li>这部分内容，你也可以放到本地调试并预览成功后并打算线上部署的时候，再回过头来看。</li></ul><h4 id="GitHub-是什么"><a href="#GitHub-是什么" class="headerlink" title="GitHub 是什么"></a>GitHub 是什么</h4><blockquote><p><a href="https://github.com/">GitHub</a> 是全世界最大的开源项目与代码托管平台，也是众多开发者的交流场所。<br>而代码托管本身用到的正是上文提到的 Git 技术。</p></blockquote><h4 id="为什么要用-GitHub"><a href="#为什么要用-GitHub" class="headerlink" title="为什么要用 GitHub"></a>为什么要用 GitHub</h4><blockquote><p>对于平民 <del>(白嫖)</del> 玩家来说，在初次尝试建立自己的网站时，也许并没有闲钱或者说能真正下决心来购买自己的服务器与域名。<br>而 GitHub 则提供了 GitHub Pages 这一服务 (一个静态站点托管服务)。<br>用户们可以利用这一服务，部署自己的静态站点。</p></blockquote><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol><li>注册 GitHub 账号；<del>（虽然都是英文，但都是一些日常用词，实在不懂也可以求助各种翻译软件）</del></li><li>登录 GitHub；</li><li>点击右上角的 + -&gt; New repository 新建仓库；</li></ol><p><img src="https://oscimg.oschina.net/oscnet/up-6b1653ade0f1f759574ed1509dae801ba45.png" alt="GitHub创建代码仓库" loading="lazy"><em>图3 GitHub创建代码仓库</em></p><ol start="4"><li>之后会跳转的如下图所示的界面，注意图中标注的三处为必填项。其中，<code>Repository name</code> 项必须是 <code>你的用户名.github.io</code>，用户名是英文，大小写无所谓，但建议统一小写；其次是仓库权限必须为 <code>Public</code>，因为 GitHUb 默认只有这种命名格式和开源权限的仓库才会开通 GitHub Pages 服务。最后，建议勾选上初始化 <code>Add a README file</code> ，因为开通 GitHub Pages 服务的仓库必须要有该文件，不过你也可以自己本地新建好，到时上传时统一上传至该仓库中；</li></ol><blockquote><p>注：之后部署到 GitHub Pages 上的静态网站的访问域名默认就是你上面设置的仓库名称。</p></blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-093e2efeff2ce06dd41dc0a6aaf9d31dd78.png" alt="GitHub创建仓库的设置" loading="lazy"><em>图4 GitHub创建仓库的设置</em></p><ol start="5"><li>点击 Create repository 之后，你将得到一个 main 分支且其中有 README.md 文件的仓库。</li></ol><blockquote><p>注意，2020 年 10 月 1 日后，GitHub 会将所有新建的仓库的默认分支从 master 修改为 main，但本地使用 git 工具初始化的仓库分支仍为 master，因此，在本地推送之前需要先先建一个 master 分支，或者使用 git 命令（该命令下文部署阶段时会给出）把本地的 master 分支强制映射至 main 分支。</p></blockquote><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><h4 id="什么是-Hexo"><a href="#什么是-Hexo" class="headerlink" title="什么是 Hexo"></a>什么是 Hexo</h4><ul><li>GitHub: <a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></li><li>官方文档：<a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></li></ul><blockquote><p>Hexo 是一个快速、简洁而强大的博客框架，基于 Node.js，同样托管于 GitHub 之上。生态中拥有众多插件主题。你可以基于它快速生成一些静态页面，或者使用别人的各种主题与插件，自己定制开发想要的功能。</p></blockquote><h4 id="安装-Hexo-工具"><a href="#安装-Hexo-工具" class="headerlink" title="安装 Hexo 工具"></a>安装 Hexo 工具</h4><ol><li>在终端输入一下命令：（使用 npm 工具下载并导入 Hexo 工具）<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">npm install hexo-cli -g&#x2F;&#x2F; 在Linux系统中，如果安装失败，可能是没有权限，可以尝试头部加上 sudo 重新执行sudo npm install hexo-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>注释：<br>install 表示安装；<br>hexo-cli 则是 Hexo 的终端工具，可以帮助你生成一些模版文件，等下马上就会用到。<br>-g 代表的是全局安装，也就是在任何地方都可以使用 Hexo 命令，否则只能在安装的目录下使用。</p></blockquote><ol start="2"><li><p>在你喜欢的位置新建一个文件夹作为你之后小站的根目录；（文件命名建议全英文，不带特殊符号）</p></li><li><p>在该文件夹中打开终端，输入以下命令：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F;在当前文件夹中初始化 Hexohexo init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>初始化之后，你会看到文件夹中多出了很多文件如下图所示；</p></li></ol><p><img src="https://oscimg.oschina.net/oscnet/up-73b9a1060549aa038021f0a7bec869be648.gif" alt="Hexo初始化演示图" loading="lazy"><em>图5 Hexo初始化演示图</em></p><blockquote><p>注意：<br>笔者在初始化的过程中出现了 <code>fatal: unable to access &#39;https://github.com/hexojs/hexo-starter.git/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054</code> 的问题，一般是因为服务器的SSL证书没有经过第三方机构的签署才报错，不影响正常的 Hexo 的使用。</p></blockquote><ul><li>此时指定文件夹的目录如下：<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">.├── _config.yml├── package.json├── scaffolds├── source|   └── _posts└── themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="5"><li><p>输入 npm 命令，安装 Hexo 的依赖模块；</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 默认安装所有 &#96;package.json&#96; 文件中提到的包npm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>最后可以启动本地 Hexo 服务器运行 Hexo 的 <code>Hello World</code> 项目，此时打开浏览器，在地址栏中输入  <code>localhost:4000</code> ，若能看到看到如下所示的网页就说明 Hexo 工具能正常使用了；</p></li></ol><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 开启本地的 Hexo 服务器命令，你也可以缩写成 hexo shexo server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://oscimg.oschina.net/oscnet/up-bd2aff13861bcbaac3778aa667def8efb07.gif" alt="Hexo本地服务器启动示意图" loading="lazy"><em>图6 Hexo本地服务器启动示意图</em></p><ol start="7"><li>按 <code>Ctrl + C</code> 中断服务器的运行。</li></ol><p>到目前为止，所需的全部基础模块都已经搭建好了。</p><h3 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h3><ul><li>当你本地测试完毕后，就可以考虑部署到远程仓库中了，因为只有这样，别人才能通过域名访问到你的小站。</li><li>为了更方便的部署到 GitHub Pages，Hexo 提供了 hexo-deployer-git 插件。</li></ul><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>先安装 hexo-deployer-git 插件；</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">npm install hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在 博客网站根目录（Hexo init 初始化的文件夹）的 _config.yml 中配置你想要远程推送的仓库地址及分支信息，其中 GitHub 远程仓库的地址位置如图7所示；</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">deploy:  type: git  # 比如HTTPS链接：https:&#x2F;&#x2F;github.com&#x2F;Horizon-x&#x2F;Horizon-x.github.io.git 或者 SSH 链接：git@github.com:Horizon-x&#x2F;Horizon-x.github.io.git  repo: 你此前新建的仓库的链接   branch: master # 默认使用 master 分支  message: Update Hexo Static Content # 你可以自定义此次部署更新的说明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><img src="https://oscimg.oschina.net/oscnet/up-39a5c056e8ae13e0e60bbf5f23bbbee00b5.png" alt="GitHub克隆地址示意图" loading="lazy"><em>图7 GitHub克隆地址示意图</em></p><blockquote><p>注意：</p><ul><li>建议使用 SSH Clone 地址，HTTPS Clone 地址有人反映可能会出现推送失败的未知错误。</li><li>若要使用 SSH Clone 地址需要在你的 GitHub 账户中配置 SSH 公钥，具体的配置方案网上的教程都很详细，笔者不在此展开。</li></ul></blockquote><ol start="3"><li>打开终端，输入以下命令，完成本地 Hexo 文件的远程推送：<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><blockquote><p>如果是使用　HTTPS　Clone 的地址，第一次可能需要你输入用户名与密码；如果是使用　SSH　Clone 的地址，第一次连接时会提示 “Are you sure you want to continue connecting (yes/no)?” ，注意此处不要默认回车，必须要手动输入 “yes” ，否则会提示推送失败。</p></blockquote><ol start="4"><li><p>等待完成后，打开网址 https://&lt;你的GitHub用户名&gt;.github.io 就能看到你刚才部署的网站了；</p></li><li><p>当然如果你还想更详细的了解部署的其他可选配置，也可以直接参考 <a href="https://hexo.io/zh-cn/docs/github-pages">Hexo 的官方文档</a>；</p></li><li><p>(可选) 在此，笔者强烈建议读者在部署完网站至 GitHub Pages 之后，启动强制 HTTPS 加密访问。</p></li></ol><blockquote><ul><li>目前 Chrome 浏览器已经默认会显示 http 链接为不安全，以至于 http 的相关页面可能无法正常打开。</li><li>所谓的 HTTPS 相较于 HTTP 就是对传输的内容做了加密，为了防止在传输过程中被他人窃取或非法篡改。</li><li>因此，为了安全起见 <del>（也为了避免使用 Chrome 浏览器时动不动就出现烦人的安全提示）</del> ，建议开启强制 https 跳转。具体操作如下：<ul><li>项目地址页面 -&gt; Settings -&gt; Options -&gt; GitHub Pages -&gt; 勾选上 Enforce HTTPS。（翻到页面下面）</li></ul></li><li>此时，会将你网站的访问地址由 http 自动重定向到 https 下。</li></ul></blockquote><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><h4 id="Hexo-自定义主题"><a href="#Hexo-自定义主题" class="headerlink" title="Hexo 自定义主题"></a>Hexo 自定义主题</h4><ul><li>笔者之所以选择使用 Hexo 工具来搭建个人博客网站，除了看中它丰富的插件生态，更重要的是 Hexo 有大量的自定义主题可供选择 <del>（只要你高兴，可以一天一个主题轮着来）</del>；</li><li>目前主要的主题商店有：<ul><li><a href="https://hexo.io/themes/">Hexo 官网</a></li><li><a href="https://github.com/search?q=hexo">GitHub</a></li></ul></li></ul><h4 id="Hexo-写作"><a href="#Hexo-写作" class="headerlink" title="Hexo 写作"></a>Hexo 写作</h4><ol><li>在博客网站的根目录中打开终端，输入以下命令即可新建 xxx.md 文件；<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">hexo new post xxx&#x2F;&#x2F; 如果输入的名称带空格可以使用双引号，但笔者强烈建议不要使用带空格的命名hexo new post &quot;xxx&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>此时新建的文件名也是你将要创作的文章标题名称。<br>md 是 Markdown 的后缀名，是一种简洁方便的文本标记语言。你只需要记住简单的几种语法，就可以快速进行编写。<br>为什么使用 Markdown？<br>首先 Hexo 本身就是将 Markdown 转化为静态的 Html 文件，来方便用户编写文章。<br>Markdown 就好似介于 Word 与 TXT 文本之间。Word 体积大、大部分功能实际上根本用不到，且最后的文档常常带有许多冗余信息。而 TXT 却无法实现加粗、标题、下划线、水平分割线等常用的功能。</p></blockquote><ol start="2"><li><p>更多关于 Markdown 语法，可以通过 <a href="https://markdown.com.cn/basic-syntax/">Markdown 中文官方教程</a> 进行学习；</p></li><li><p>为你的文章添加标签/分类/日期等扩展信息，可以在 <a href="https://hexo.io/zh-cn/docs/front-matter.html">Hexo 关于 Front-matter 的官方文档</a> 中找到案例示范。</p></li></ol><h4 id="Hexo-新建页面"><a href="#Hexo-新建页面" class="headerlink" title="Hexo 新建页面"></a>Hexo 新建页面</h4><p>你可以新建一些自己的自定义页面，主要有两种方式：</p><ul><li>直接在 Hexo 目录下的 source 文件夹下直接新建 HTML 进行编写。</li><li>（推荐方式）也可以通过以下 Hexo 命令来新建页面。<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">hexo new page xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>当然还是 Markdown，不过也是可以在 Markdown 里写 HTML 的，也会被渲染出来。</p></blockquote></li></ul><p>至此，整个网站的搭建及部署告一段落，可以正式开始你的创作之旅啦。</p><blockquote><p>既然选择了远方，便只顾风雨兼程</p></blockquote>]]></content>
    
    
    <summary type="html">手把手教你如何快速搭建起属于自己的小站</summary>
    
    
    
    <category term="MyBlogs系列" scheme="https://www.onexstone.online/categories/MyBlogs%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="MyBlogs" scheme="https://www.onexstone.online/tags/MyBlogs/"/>
    
    <category term="QuickStart" scheme="https://www.onexstone.online/tags/QuickStart/"/>
    
  </entry>
  
  <entry>
    <title>Java项目中的ClassPath的前世今生</title>
    <link href="https://www.onexstone.online/posts/ef0e997a/"/>
    <id>https://www.onexstone.online/posts/ef0e997a/</id>
    <published>2021-09-26T07:06:39.000Z</published>
    <updated>2021-09-26T07:24:03.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java项目的classpath是什么？"><a href="#1-Java项目的classpath是什么？" class="headerlink" title="1. Java项目的classpath是什么？"></a>1. Java项目的classpath是什么？</h3><ul><li> 定义：<code>classpath</code> 就是 <code>class</code> 的 <code>path</code> ，直译就是指类文件 ( <code>*.class</code> ) 的路径。</li></ul><span id="more"></span><h3 id="2-用途"><a href="#2-用途" class="headerlink" title="2.  用途"></a>2.  用途</h3><ul><li><code>classpath</code> 的作用就是通知 <code>JVM</code> (Java虚拟机) 用户类的存放路径。当运行我们的 <code>Java</code> 程序时，<code>JVM</code> 会按照 <code>classpath</code> 指定的文件中去查找相应类的 <code>*.class</code> 文件。</li><li>我们在指定一些 配置/资源 文件的时候也会使用到 <code>classpath</code>。例如，在 <code>web.xml</code> 中指定 <code>springMVC</code> 的配置文件，如下图，<code>classpath: entry/dev/spring-mvc.xml</code>。<br><img src="https://oscimg.oschina.net/oscnet/up-19a35a6a2db5669afaca626ba53a7edcd3d.png" alt="springMVC 的配置文件" loading="lazy"><em>springMVC 的配置文件</em></li><li>再比如，当我们把 <code>*Mapper.xml</code> 文件放在了 <code>src/main/java/../mapping/</code> 文件夹下时，在 <code>mybatis</code> 的配置文件中配置其位置。<br><img src="https://oscimg.oschina.net/oscnet/up-f0f15e3c6a331d3bc3e21ad3cccde1d3393.png" alt="Mybits的配置文件" loading="lazy"><em>Mybits的配置文件</em></li><li>很显然，上面这 2 个 <code>classpath</code> 的配置，是为了告诉配置文件，去哪里寻找我们要指定的配置文件。</li></ul><h3 id="3-解释"><a href="#3-解释" class="headerlink" title="3.  解释"></a>3.  解释</h3><p>要想弄清楚为什么是上面这样写的，我们就要来看看项目运行时（或者是发布后）的目录结构了，首先：</p><ul><li>以一个普通的 <code>JavaWeb</code> 项目为例，根据 <code>maven</code> 的约定，一般我们的项目结构就像下面这样。<br><img src="https://oscimg.oschina.net/oscnet/up-0ab81070cc2a3d5191957d0d5d755d8a068.png" alt="JavaWeb项目的目录结构" loading="lazy"><em>JavaWeb项目的目录结构</em></li><li>我们使用 IDEA 对项目进行打包，一种是 <code>war</code> 包，一种是 <code>explorer</code> 的文件夹， <code>war</code> 包解压后就是 <code>explorer</code> 了。我们来对解压后的目录结构进行分析。</li><li>经过对比，我们要注意到，开发时期的项目里，<code>src/main/</code> 下面的 <code>java</code> 和 <code>resources</code> 文件夹都被(编译)打包到了生产包的 <code>WEB-INF/classes/</code> 目录下；而原来 <code>WEB-INF</code> 下面的 <code>views</code> 和 <code>web.xml</code> 则仍然还是在 <code>WEB-INF</code> 下面。同时由 <code>maven</code> 引入的依赖都被放入到了 <code>WEB-INF/lib/</code> 下面。最后，编译后的 <code>class</code> 文件和资源文件都放在了 <code>classes</code> 目录下。<br><img src="https://oscimg.oschina.net/oscnet/up-1e219408177c6b48092fcdc6073a67ec8cf.png" alt="JavaWeb项目打包后的目录结构" loading="lazy"><em>JavaWeb项目打包后的目录结构</em></li></ul><h3 id="4-classpath-的真面目"><a href="#4-classpath-的真面目" class="headerlink" title="4.  classpath 的真面目"></a>4.  <code>classpath</code> 的真面目</h3><ul><li>在编译打包后的项目中，根目录是 <code>META-INF</code> 和 <code>WEB-INF</code> 。这个时候，我们可以看到 <code>classes</code> 这个文件夹，它就是我们要找的 <code>classpath</code>。</li><li>在第 1 个例子里，<code>classpath:entry/dev/spring-mvc.xml</code> 中， <code>classpath</code> 就是指 <code>WEB-INF/classes/</code> 这个目录的路径。需要声明的一点是，使用 <code>classpath</code> : 这种前缀，就只能代表一个文件。</li><li>在第 2 个例子里，<code>classpath*:**/mapper/mapping/*Mapper.xml</code>，使用 <code>classpath*</code> : 这种前缀，则可以代表多个匹配的文件；<code>**/mapper/mapping/*Mapper.xml</code> ，双星号 <code>**</code> 表示在任意目录下，也就是说在 <code>WEB-INF/classes/</code> 下任意层的目录，只要符合后面的文件路径，都会被作为资源文件找到。</li></ul><h3 id="5-如何获取项目类编译后的路径"><a href="#5-如何获取项目类编译后的路径" class="headerlink" title="5.  如何获取项目类编译后的路径"></a>5.  如何获取项目类编译后的路径</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">String path &#x3D; 类名.class.getClassLoader().getResource(&quot;&quot;).getPath();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.  总结"></a>6.  总结</h3><ul><li>  首先 <code>classpath</code> 是指 <code>WEB-INF</code> 文件夹下的 <code>classes</code> 目录。</li><li>解释 <code>classes</code> 含义：<ul><li>  存放各种资源配置文件 <code>init.properties、log4j.properties、struts.xml</code>；</li><li>  存放模板文件 <code>actionerror.ftl</code>；</li><li>  存放 <code>class</code> 文件，对应的是项目开发时 <code>src</code> 目录中 <code>Java</code> 源码的编译文件；</li></ul></li><li>  本质：<strong>这是一个定位资源的入口。</strong></li></ul><hr>]]></content>
    
    
    <summary type="html">结合项目案例分析Java项目中的ClassPath的作用</summary>
    
    
    
    <category term="Java" scheme="https://www.onexstone.online/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.onexstone.online/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>快速搭建一个简易的SpringBoot项目</title>
    <link href="https://www.onexstone.online/posts/78dbede3/"/>
    <id>https://www.onexstone.online/posts/78dbede3/</id>
    <published>2021-09-26T06:37:20.000Z</published>
    <updated>2021-09-30T08:25:54.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-本文将手把手教大家搭建一个简易但完整的SpringBoot项目。"><a href="#1-本文将手把手教大家搭建一个简易但完整的SpringBoot项目。" class="headerlink" title="1. 本文将手把手教大家搭建一个简易但完整的SpringBoot项目。"></a>1. 本文将手把手教大家搭建一个简易但完整的SpringBoot项目。</h3><span id="more"></span><h3 id="2-搭建环境："><a href="#2-搭建环境：" class="headerlink" title="2. 搭建环境："></a>2. 搭建环境：</h3><pre><code>- JDK：    - java version &quot;1.8.0_202&quot;    - Java(TM) SE Runtime Environment (build 1.8.0_202-b08)    - Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)- OS：Windows 10- IDE：IntelliJ IDEA 2021.1.3 (Ultimate Edition)</code></pre><h3 id="3-初始化-SpringBoot-项目"><a href="#3-初始化-SpringBoot-项目" class="headerlink" title="3. 初始化 SpringBoot 项目"></a>3. 初始化 <code>SpringBoot</code> 项目</h3><p>首先，我们先使用 <code>Spring Initializr</code> 初始化一个 <code>SpringBoot</code> 项目。</p><ul><li><p>3.1 打开 <code>IDEA</code> 的引导页面，选择 <code>New Project</code> 按钮。<br><img src="https://oscimg.oschina.net/oscnet/up-19480791ef100df655561f1499e95acc969.png" alt="IDEA引导页" loading="lazy"><em>图一 IDEA 引导页</em></p></li><li><p>或者进入 <code>IDEA</code> 后点击上方菜单栏，依次选择 <code>File</code> &gt; <code>New</code> 菜单下选择 <code>Project</code> 菜单栏。</p></li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-b1b51448fa34eaaf26d1a88e84ab91b7163.png" alt="菜单启动页" loading="lazy"><em>图二 菜单启动页</em></p><ul><li>3.2 此时，将会打开 <code>Spring Initializr</code> 项目向导的第一页，你会发现这个页面上有很多输入域与Maven pom.xml 文件中的信息是一致的，实际上，Tpye 输入域中选择 Maven ，就应该明白这些输入域的用途所在。如果想使用与 <a href="https://start.spring.io/">https://start.spring.io</a> 不同的 <code>Spring Initializr</code> ，就可以选择 <code>Server URL</code> 项右侧的设置图标，在弹出的文本框中输入想要使用的 <code>Spring Initializr</code> 的基础 <code>URL</code>。一般选择默认的官方网站即可。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-db18bd32f1c6fdad3ffe97ce04d51548936.png" alt="SpringInitializr引导页1" loading="lazy"><em>图三 SpringInitializr 引导页1</em></p><p><img src="https://oscimg.oschina.net/oscnet/up-01a3f9e0b03eead2f75ada03e9105a9609f.png" alt="SpringInitializr引导页2" loading="lazy"><em>图四 修改 Server URL 图</em></p><ul><li>3.3 在填写完必要的项目信息后，点击 Next 按钮将会进入到项目依赖引导页，其中左侧可以看到，依赖是按照目的分类来组织的，选中某个分类，就会显示出该分类下的全部的可选项。按照你的项目需求选择合适的依赖组件，选中的组件会依次显示在右下角的方框中。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-683ef49348f15b5424369871e5c907965a9.png" alt="SpringInitializr依赖页" loading="lazy"><em>图五 SpringInitializr 依赖页</em></p><ul><li>3.4 最后，点击 Finish 按钮，项目将会创建并加载到 IDEA 的工作空间，其中SpringBoot初始化生成的项目目录结构如图七所示。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-c314be5533bd6aee9d9de09906426c48eb8.png" alt="SpringBoot项目启动页" loading="lazy"><em>图六 SpringBoot 项目启动页</em></p><p><img src="https://oscimg.oschina.net/oscnet/up-f2fec315db9c5471d28755b52099766a7d1.png" alt="SpringBoot初始化生成的项目目录结构" loading="lazy"><em>图七 SpringBoot 初始化生成的目录结构</em></p><hr><h3 id="4-项目测试"><a href="#4-项目测试" class="headerlink" title="4. 项目测试"></a>4. 项目测试</h3><p>既然项目已经自动生成好了，那我们接下来当然是要测试一下项目是否真的能正常运行啦。</p><ul><li>4.1 首先，我们先新建一个包（<code>com.horizon.demo</code>），然后在该包下新建一个控制器类 <code>HomeController</code>，用来处理 <code>Web</code> 请求。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-2217fb1a8a48786a3f11b18f6345e6cb9ba.png" alt="homeController" loading="lazy"><em>图八 homeController 类</em></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Controllerpublic class HomeController &#123;    &#x2F;&#x2F;一个简单的controller，返回名为&quot;home&quot;的逻辑视图名    @GetMapping(&quot;&#x2F;&quot;)    public String home() &#123;        return &quot;home&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>4.2 接下来要定义一个名为 <code>home</code> 的视图，以完成整个 <code>web</code> 请求。为了让主页尽可能简单，除了欢迎用户访问站点之外，它不会做其他的任何事。唯一需要注意的一行代码是用于展现 <code>Home</code> 的 <code>&lt;img&gt;</code> 标签，它使用了 <code>Thymeleaf</code> 的 <code>th:src</code> 属性和 <code>@&#123;...&#125;</code> 表达式，以便于引用相对于上下文路径的图片。</li></ul><blockquote><p>注：图片是使用相对于上下文的 <code>&quot;/images/home.jpg&quot;</code> 路径来进行引用的。回忆一下我们的项目结构，像图片这样的静态资源是放到 <code>&quot;/src/main/resources&quot;</code> 文件夹中的。这意味着，在该项目中，<code>home</code> 图片必须要位于 <code>&quot;/src/main/resources/static/images/home.jpg&quot;</code> 。</p></blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-7cf103837957a293c210d1fd0132fcc939f.png" alt="homePage页面" loading="lazy"><em>图九 homePage 页面</em></p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;        xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Horizon-Home&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;Welcome to...&lt;&#x2F;h1&gt;    &lt;h3&gt;This is the Horizon‘s Home.&lt;&#x2F;h3&gt;    &lt;img th:src&#x3D;&quot;@&#123;&#x2F;images&#x2F;home.jpg&#125;&quot;&#x2F;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>4.3 目前，我们已经有了一个处理主页请求的控制器并且有了渲染主页的模板，那我们基本就可以启动应用来看一下它的效果了。我们在 <code>/src/test/java/com/horizon/demo</code> 包下新建一个 <code>HomeControllerTest </code> 的测试类。</li></ul><blockquote><p>通过 <code>testHomePage()</code> 方法，我们定义了针对主页想要执行的测试。它首先使用 <code>MockMvc</code> 对象对 <code>&quot;/&quot;</code> （根路径）发起 <code>HTTP GET</code> 请求。对于这个请求，我们设置了如下的预期：<br>    - 响应应该具备 <code>HTTP 200 (OK)</code> 状态;<br>    - 视图的逻辑名称应该是 <code>home</code>;<br>    - 渲染后的视图应该包含文本 <code>&quot;Welcome to...&quot;</code>。</p></blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-11de89919acb44eb25c538be34d5f3dffec.png" alt="HomeControllerTest.png" loading="lazy"><em>图十 HomeControllerTest 类</em></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RunWith(SpringRunner.class)@WebMvcTest(HomeController.class) &#x2F;&#x2F;针对 HomeController 的 Web 测试public class HomeControllerTest &#123;    @Autowired &#x2F;&#x2F;自动注入 MockMvc 类    private MockMvc mockmvc;    @Test    public void testHomePage () throws Exception &#123;        mockmvc.perform(get(&quot;&#x2F;&quot;)) &#x2F;&#x2F;发起对路径为 “&#x2F;” 的 GET 请求                .andExpect(status().isOk()) &#x2F;&#x2F;期望得到 HTTP 200 的响应状态码                .andExpect(view().name(&quot;home&quot;))&#x2F;&#x2F;期望得到 home 视图                .andExpect(content().string(                        containsString(&quot;Welcome to...&quot;)));&#x2F;&#x2F;期望页面内容包含 &quot;Welcome to...&quot;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>4.4 如果在 MockMvc 对象发送请求之后，这些期望有不满足的话，那么这个测试会失败。但是，我们的控制器和模板引擎在编写的时候都满足了这些预期，所以测试应该能够通过，并且带有成功的图标 —— 至少能够看到一些绿色的背景，表明测试通过了。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-4c1e79b88d50873b5c8994fb54f60fa1047.gif" alt="testHomeControllerSuccess" loading="lazy"><em>图十一 测试 HomeController</em></p><ul><li>4.5 尽管测试已经通过了，但是如果能够在浏览器中看到结果那会更有成就感，毕竟这才是我们编写这个项目的最终目的。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-a2252d1b86b561a8bca5b16d7c6c73abc8b.gif" alt="testHomePageSuccess" loading="lazy"><em>图十二 测试 HomePage</em></p><ul><li>4.6 最终的项目结构如下图所示。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-fab1d1bc3043ad76ea211c97f136c55bdad.png" alt="testHomePageSuccess" loading="lazy"><em>图十三 完整的项目目录结构</em></p><hr><h3 id="5-测试过程中遇到的问题"><a href="#5-测试过程中遇到的问题" class="headerlink" title="5. 测试过程中遇到的问题"></a>5. 测试过程中遇到的问题</h3><ul><li><p>出现 <code>Spring Boot——[java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration]</code><br>  <img src="https://oscimg.oschina.net/oscnet/up-cd604a634586a078a5c66b1f5836dee7138.png" alt="HomeControllerFailed" loading="lazy"><em>图十四 HomeController 测试失败堆栈信息图</em></p></li><li><p>问题分析：<br>  Spring Boot的启动类没在根目录下。由于新建的 <code>com.horizon.demo</code> 包前缀和 <code>com.horizon.xxx</code> 的相同，导致生成的 <code>SpringBootDemoApplication</code> 启动类不再在项目的根目录 <code>/src/main/java/com/horizon</code>下，使得 <code>SpringBoot</code> 找不到主类，也就无法成功初始化 <code>Spring</code> 应用上下文。 </p></li><li><p>解决方案：</p><ul><li>方案一：<code>Class</code><br>  在根目录下写一个 <code>SpringBoot</code> 的启动类。</li><li>方案二：注解<br>  在类上加上下面任意一种注解。      <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@SpringBootTest(classes &#x3D; Application.class)或者@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes &#x3D; &#123;JPAConfig.class&#125;)或者@RunWith(SpringRunner.class)@ContextConfiguration(classes &#x3D; &#123;JPAConfig.class&#125;)或者@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value&#x3D;&#123;&quot;myJPAConfig.xml&quot;&#125;)或者@RunWith(SpringRunner.class)@ContextConfiguration(value&#x3D;&#123;&quot;myJPAConfig.xml&quot;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><hr><h3 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h3><ol><li>Craig Walls．Spring实战 [M]. 北京：人民邮电出版社，2020：1-26.</li></ol>]]></content>
    
    
    <summary type="html">保姆式教程，Queck Start SpringBoot Project</summary>
    
    
    
    <category term="Spring" scheme="https://www.onexstone.online/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://www.onexstone.online/tags/Java/"/>
    
    <category term="QuickStart" scheme="https://www.onexstone.online/tags/QuickStart/"/>
    
    <category term="SpringBoot" scheme="https://www.onexstone.online/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>初尝Java的语法糖</title>
    <link href="https://www.onexstone.online/posts/d2e8c2c4/"/>
    <id>https://www.onexstone.online/posts/d2e8c2c4/</id>
    <published>2021-09-26T06:28:44.000Z</published>
    <updated>2021-09-26T06:33:21.506Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是语法糖？"><a href="#1-什么是语法糖？" class="headerlink" title="1. 什么是语法糖？"></a>1. 什么是语法糖？</h3><blockquote><ul><li>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</li><li>需要声明的是 “语法糖” 这个词绝非贬义词，它可以给我们带来方便，是一种便捷的写法，编译器会帮我们做转换；而且可以提高开发编码的效率，在性能上也不会带来损失。</li></ul></blockquote><span id="more"></span><h3 id="2-Java-中的语法糖体现在哪？"><a href="#2-Java-中的语法糖体现在哪？" class="headerlink" title="2. Java 中的语法糖体现在哪？"></a>2. Java 中的语法糖体现在哪？</h3><ul><li>前面提到过，语法糖的存在主要是方便开发人员使用。但其实，<code>Java</code> 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</li><li>说到编译，大家肯定都知道，<code>Java</code> 语言中，<code>javac</code> 命令可以将后缀名为 <code>.java</code> 的源文件编译为后缀名为 <code>.class</code> 的可以运行于 <code>Java</code> 虚拟机的字节码。</li><li>如果你去看 <code>com.sun.tools.javac.main.JavaCompiler</code> 的源码，你会发现在 <code>compile()</code> 中有一个步骤就是调用 <code>desugar()</code> ，这个方法就是负责解语法糖的实现。</li><li>在 <code>Java</code> 中,目前存在的语法糖包含 <code>数字字面量、条件编译、断言、Switch语句与枚举及字符串结合、可变参数、自动装箱/拆箱、枚举、内部类、泛型擦除、增强for循环、lambda表达式、try-with-resources语句</code> 等等。</li></ul><h3 id="3-环境"><a href="#3-环境" class="headerlink" title="3. 环境"></a>3. 环境</h3><pre><code>- JDK：    - java version &quot;1.8.0_202&quot;    - Java(TM) SE Runtime Environment (build 1.8.0_202-b08)    - Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)- OS：Windows 10</code></pre><h3 id="4-反编译工具"><a href="#4-反编译工具" class="headerlink" title="4. 反编译工具"></a>4. 反编译工具</h3><ul><li>关于反编译工具, 其实在 <code>JDK</code> 中自带了一个 <code>javap</code> 命令, 但是日常中很少会用到 <code>javap</code> , 所以这次我打算借助另一个反编译工具 <code>CFR</code> 来分析 <code>Java</code> 中的语法糖, 这里我下载的是最新的 <a href="https://github.com/leibnitz27/cfr">cfr_0_151.jar</a>。</li></ul><h3 id="5-语法糖解析"><a href="#5-语法糖解析" class="headerlink" title="5. 语法糖解析"></a>5. 语法糖解析</h3><h4 id="1-字符串拼接"><a href="#1-字符串拼接" class="headerlink" title="1. 字符串拼接"></a>1. 字符串拼接</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;*** 字符串拼接* option: --stringbuilder false*&#x2F;public void stringBuilderTest(int end) &#123;    char[] foo &#x3D; new char[]&#123;&#39;@&#39;, &#39;a&#39;, &#39;*&#39;&#125;;    char ch;    int x &#x3D; 0;    while ((ch &#x3D; foo[++x]) !&#x3D; &#39;*&#39;) &#123;        System.out.println(&quot;&quot; + x + &quot;: &quot; + ch);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CRF 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr_0_132.jar CFRDecompilerDemo.class --stringbuilder false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;* * Decompiled with CFR 0.151. *&#x2F;public void stringBuilderTest() &#123;    char ch;    char[] foo &#x3D; new char[]&#123;&#39;@&#39;, &#39;a&#39;, &#39;*&#39;&#125;;    int x &#x3D; 0;    while ((ch &#x3D; foo[++x]) !&#x3D; &#39;*&#39;) &#123;        System.out.println(new StringBuilder().append(x).append(&quot;: &quot;).append(ch).toString());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 从反编译后的代码中能看出, 当我们使用 `+` 号进行字符串拼接操作时, 编译时会自动创建一个 `StringBuilder` 对象。所以在循环中拼接字符串时, 应避免使用 `+` 号操作, 否则每次循环都会创建一个 `StringBuilder` 对象再回收, 造成较大的开销。</code></pre><hr><h4 id="2-条件编译"><a href="#2-条件编译" class="headerlink" title="2. 条件编译"></a>2. 条件编译</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 条件编译 * option: 不需要参数 *&#x2F;public void ifCompilerTest() &#123;    if(false) &#123;        System.out.println(&quot;false if&quot;);    &#125;else &#123;        System.out.println(&quot;true else&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar ifCompilerTest.class<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void ifCompilerTest() &#123;    System.out.println(&quot;true else&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>- 分析：&gt;  - `javac` 编译器在编译时期的解语法糖阶段, 会将条件分支不成立的代码进行消除。</code></pre><hr><h4 id="3-断言"><a href="#3-断言" class="headerlink" title="3. 断言"></a>3. 断言</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 断言, JDK1.4开始支持 * option: --sugarasserts false *&#x2F;public void assertTest(String s) &#123;    assert (!s.equals(&quot;Fred&quot;));    System.out.println(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar assertTest.class --sugarasserts false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void assertTest(String s) &#123;    if (!$assertionsDisabled &amp;&amp; s.equals(&quot;Fred&quot;)) &#123;        throw new AssertionError();    &#125;    System.out.println(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt;  - 我们可以发现其实断言的底层实现就是 `if` 判断语句，当断言结果为 `true` 时, 程序继续正常执行, 当断言结果为 `false` 时, 则抛出 `AssertionError` 异常来打断程序的执行。&gt; - 同时，我们还可以看到 `javac` 编译器还添加了一个新的变量 `$assertionsDisabled`，回想一下我们想让虚拟机启用断言功能的时候，命令行指令为 ```java -ea xxx.java```。但为什么一定要加上 `-enableassertions (简写：-ea)` 参数呢？其实现在的你应该清楚了，就是想要告诉虚拟机把 `$assertionsDisabled` 字段的值设置成 `false`。</code></pre><hr><h4 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4. 枚举"></a>4. 枚举</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 枚举, JDK1.5开始支持 * option: --sugarenums false *&#x2F;public enum EnumTest &#123;    FOO, BAR, BAP&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar EnumsTest.class --sugarenums false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final class EnumTestextends Enum&lt;EnumTest&gt; &#123;    public static final &#x2F;* enum *&#x2F; EnumTest FOO &#x3D; new EnumTest(&quot;FOO&quot;, 0);    public static final &#x2F;* enum *&#x2F; EnumTest BAR &#x3D; new EnumTest(&quot;BAR&quot;, 1);    public static final &#x2F;* enum *&#x2F; EnumTest BAP &#x3D; new EnumTest(&quot;BAP&quot;, 2);    private static final &#x2F;* synthetic *&#x2F; EnumTest[] ENUM$VALUES;    static &#123;        ENUM$VALUES &#x3D; new EnumTest[]&#123;FOO, BAR, BAP&#125;;    &#125;    private EnumTest(String string, int n) &#123;        super(string, n);    &#125;    public static EnumTest[] values() &#123;        EnumTest[] enumTestArray &#x3D; ENUM$VALUES;        int n &#x3D; enumTestArray.length;        EnumTest[] enumTestArray2 &#x3D; new EnumTest[n];        System.arraycopy(ENUM$VALUES, 0, enumTestArray2, 0, n);        return enumTestArray2;    &#125;    public static EnumTest valueOf(String string) &#123;        return Enum.valueOf(EnumTest.class, string);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 当我们自定义一个枚举类型时, 编译器会自动创建一个被 `final` 修饰的枚举类来继承 `Enum` 类, 所以自定义的枚举类型是 **无法继承和被继承的**。当枚举类初始化时, 枚举字段引用该枚举类的一个静态常量对象, 并且所有的枚举字段都用常量数组 `$VALUES` 来存储。`values()` 方法内则调了用 `System.arraycopy` 方法, 参照 `$VALUES` 数组对象复制一个新的数组, 新数组会有所有的枚举字段。&gt; - 注意，在定义的枚举常量后都跟着一个数字，至于他是干嘛用的，等看完下一个语法糖后你就应该知道了。</code></pre><hr><h4 id="5-枚举与-Switch-语句"><a href="#5-枚举与-Switch-语句" class="headerlink" title="5. 枚举与 Switch 语句"></a>5. 枚举与 Switch 语句</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 枚举与Switch语句 * option: --decodeenumswitch false *&#x2F;public int switchEnumTest(EnumTest e) &#123;    switch (e) &#123;        case FOO:            return 1;        case BAP:            return 2;    &#125;    return 0;&#125;&#x2F;** * 枚举, JDK1.5开始支持 * option: --sugarenums false *&#x2F;public enum EnumTest &#123;    FOO,    BAR,    BAP&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar switchEnumTest.class --decodeenumswitch false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int switchEnumTest(EnumTest e) &#123;    switch (StringBuilderTest.$SWITCH_TABLE$com$xxx$SyntacticSugar$switchEnumTest$EnumTest()[e.ordinal()]) &#123;        case 1: &#123;            return 1;        &#125;        case 3: &#123;            return 2;        &#125;    &#125;    return 0;&#125;static &#x2F;* synthetic *&#x2F; int[] $SWITCH_TABLE$com$xxx$SyntacticSugar$switchEnumTest$EnumTest() &#123;    if ($SWITCH_TABLE$com$xxx$SyntacticSugar$switchEnumTest$EnumTest !&#x3D; null) &#123;        return $SWITCH_TABLE$com$xxx$SyntacticSugar$switchEnumTest$EnumTest;    &#125;    int[] nArray &#x3D; new int[EnumTest.values().length];    try &#123;        nArray[EnumTest.BAP.ordinal()] &#x3D; 3;    &#125;    catch (NoSuchFieldError noSuchFieldError) &#123;&#125;    try &#123;        nArray[EnumTest.BAR.ordinal()] &#x3D; 2;    &#125;    catch (NoSuchFieldError noSuchFieldError) &#123;&#125;    try &#123;        nArray[EnumTest.FOO.ordinal()] &#x3D; 1;    &#125;    catch (NoSuchFieldError noSuchFieldError) &#123;&#125;    $SWITCH_TABLE$com$xxx$SyntacticSugar$switchEnumTest$EnumTest &#x3D; nArray;    return nArray;&#125;public static enum EnumTest &#123;    FOO,    BAR,    BAP;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - `switch` 支持枚举是通过调用枚举类默认继承的父类 `Enum` 中的 `ordinal()` 方法来实现的, 这个方法会返回枚举常量的序数。&gt; - 而这个枚举常量的序数又是从哪来的呢？通过对比上一小节的 `EnumTest` 源码和反编译后的代码我们可以看到，这个数字其实就是编译器在声明一个枚举常量的时候，按照我们声明枚举元素的顺序加的一个序数。在实现 `switch` 语句的时候首先会给枚举元素“赋值”，所谓的“赋值”就是新建一个 int 数组，然后按照枚举元素的序号，在数组的对应位置上赋上一个 `int` 值，方便后续 `switch` 分支的匹配。这也解释了反编译后的源码中为什么 `switch` 分支的匹配条件从枚举元素名称，变成了对应枚举元素在 `nArray` 数组上的值。&gt; - 但为什么要多此一举去改变它们呢？其实 `Java` 规定了 `switch` 语句中的变量类型只能是： `byte` 、`short` 、`int` 或者 `char`。但从 `Java SE 7` 开始，`switch` 支持字符串 `String` 类型了，同时 `case` 标签必须为字符串常量或字面量。所以在 `Java SE 7` 以前的 `Java` 版本中若想实现 `swich` 语句用 `String` 类型的字符串作为条件，就得使用枚举类型来作为桥梁。</code></pre><hr><h4 id="6-字符串与-Switch-语句"><a href="#6-字符串与-Switch-语句" class="headerlink" title="6. 字符串与 Switch 语句"></a>6. 字符串与 Switch 语句</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**  * 字符串与Switch语句 * option: --decodestringswitch false *&#x2F;public int switchStringTest(String s) &#123;    switch (s) &#123;        default:            System.out.println(&quot;Test&quot;);            break;        case &quot;BB&quot;:  &#x2F;&#x2F; BB and Aa have the same hashcode.            return 12;        case &quot;Aa&quot;:        case &quot;FRED&quot;:            return 13;    &#125;    System.out.println(&quot;Here&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar switchStringTest.class --decodestringswitch false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;* * Enabled aggressive block sorting *&#x2F;public int switchStringTest(String s) &#123;    String string &#x3D; s;    switch (string.hashCode()) &#123;        case 2112: &#123;            if (string.equals(&quot;BB&quot;)) return 12;            if (string.equals(&quot;Aa&quot;)) return 13;            break;        &#125;        case 2166379: &#123;            if (string.equals(&quot;FRED&quot;)) return 13;        &#125;    &#125;    System.out.println(&quot;Test&quot;);    System.out.println(&quot;Here&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - `switch` 支持字符串是通过 `hashCode()` 和 `equals()` 方法来实现的, 先通过 `hashCode()` 返回的哈希值进行 `switch`, 然后通过`equals()` 方法比较进行安全检查, 调用 `equals()` 是为了防止可能发生的哈希碰撞。&gt; - **小总结：综合前三小节，（另外补充一点 switch 支持 char 类型是通过比较它们的  ascii 码来实现的，同时 ascii 码是整型。）所以  switch  其实只支持一种数据类型, 也就是整型, 其他诸如  String 、枚举类型都是转换成整型之后再使用  switch 的。**</code></pre><hr><h4 id="7-可变参数"><a href="#7-可变参数" class="headerlink" title="7. 可变参数"></a>7. 可变参数</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 可变参数 * option: --arrayiter false *&#x2F;public void varargsTest(String ... arr) &#123;    for (String s : arr) &#123;        System.out.println(s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar varargsTest.class --arrayiter false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void varargsTest(String ... arr) &#123;    String[] stringArray &#x3D; arr;    int n &#x3D; arr.length;    int n2 &#x3D; 0;    while (n2 &lt; n) &#123;        String s &#x3D; stringArray[n2];        System.out.println(s);        ++n2;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 可变参数其实就是一个不定长度的数组, 数组长度随传入方法的对应参数个数来决定。可变参数只能在参数列表的末位使用。</code></pre><hr><h4 id="8-自动装箱-拆箱"><a href="#8-自动装箱-拆箱" class="headerlink" title="8. 自动装箱/拆箱"></a>8. 自动装箱/拆箱</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 自动装箱&#x2F;拆箱 * option: --sugarboxing false *&#x2F;public Double autoBoxingTest(Integer i, Double d) &#123;    return d + i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar autoBoxingTest.class --sugarboxing false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public Double autoBoxingTest(Integer i, Double d) &#123;    return Double.valueOf((double)(d.doubleValue() + (double)i.intValue()));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 首先我们知道, 基本类型与包装类型在某些操作符的作用下, 包装类型调用 `valueOf()` 方法的过程叫做装箱, 调用 `xxxValue()` 方法的过程叫做拆箱。所以上面的结果很容易看出, 先对两个包装类进行拆箱, 再对运算结果进行装箱。</code></pre><hr><h4 id="9-内部类"><a href="#9-内部类" class="headerlink" title="9. 内部类"></a>9. 内部类</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int x &#x3D; 3;&#x2F;*** 内部类* option: --removeinnerclasssynthetics false*&#x2F;public class StringTest &#123;    public void innerClassTest() &#123;        new InnerClass().getSum(6);    &#125;    public class InnerClass &#123;        public int getSum(int y) &#123;            x +&#x3D; y;            return x;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar StringTest.class --removeinnerclasssynthetics false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void innerClassTest() &#123;    new InnerClass(this).getSum(6);&#125;public class InnerClass &#123;    final &#x2F;* synthetic *&#x2F; StringTest this$0;    public InnerClass(StringTest stringTest) &#123;        this.this$0 &#x3D; stringTest;    &#125;    public int getSum(int y) &#123;        this.this$0.x +&#x3D; y;        return this.this$0.x;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 首先我们要明确, 上述 `innerClassTest()` 方法中的 `this` 是外部类当前对象的引用, 而 `InnerClass` 类中的 `this` 则是内部类当前对象的引用。编译过程中, 编译器会自动在内部类定义一个外部类的常量引用 `this$0`, 并且在内部类的构造器中初始化 `this$0`, 当外部类访问内部类时, 会把当前外部类的对象引用 `this` 传给内部类的构造器用于初始化, 这样内部类就能通过所持有的外部类的对象引用, 来访问外部类的所有公有及私有成员。&gt; - 另外，`StringTest.java` 里面定义了一个内部类 `InnerClass` ，一旦编译成功，就会生成两个完全不同的 `.class` 文件了，分别是 `StringTest.class` 和 `StringTest$InnerClass.class` 。所以内部类的名字完全可以和它的外部类名字相同。</code></pre><hr><h4 id="10-泛型擦除"><a href="#10-泛型擦除" class="headerlink" title="10. 泛型擦除"></a>10. 泛型擦除</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;*** 泛型擦除* option: 不需要参数*&#x2F;public void genericEraseTest() &#123;    List&lt;String&gt; list &#x3D;  new ArrayList&lt;String&gt;();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar genericEraseTest.class<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void genericEraseTest() &#123;    ArrayList list &#x3D; new ArrayList();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 在 `JVM` 中没有泛型这一概念,  只有普通方法和普通类, 所有泛型类的泛型参数都会在编译时期被擦除, 所以泛型类并没有自己独有的 `Class` 类对象比如 `List&lt;Integer&gt;.class` , 而只有 `List.class` 对象。</code></pre><hr><h4 id="11-增强-For-循环"><a href="#11-增强-For-循环" class="headerlink" title="11. 增强 For 循环"></a>11. 增强 For 循环</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * 增强for循环 * option: --collectioniter false *&#x2F;public void forLoopTest() &#123;    String[] qingshanli &#x3D; &#123;&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&#125;;      List&lt;String&gt; list &#x3D;  Arrays.asList(qingshanli);    for (Object s : list) &#123;        System.out.println(s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar forLoopTest.class --collectioniter false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void forLoopTest() &#123;    String[] qingshanli &#x3D; new String[]&#123;&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&#125;;    List&lt;String&gt; list &#x3D; Arrays.asList(qingshanli);    Iterator&lt;String&gt; iterator &#x3D; list.iterator();    while (iterator.hasNext()) &#123;        String s &#x3D; iterator.next();        System.out.println((Object)s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 很明显, 增强for循环的底层其实还是通过迭代器来实现的, 这也就解释了为什么增强for循环中不能进行增删改操作。&gt; - 补充：`Iterator` 是工作在一个独立的线程中，并且拥有一个` mutex` 锁。 `Iterator` 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候,若对象内容发生了改变，就可能找不到要迭代的对象，所以按照 `fail-fast` 原则 `Iterator` 会马上抛出 `java.util.ConcurrentModificationException` 异常。</code></pre><hr><h4 id="12-lambda表达式"><a href="#12-lambda表达式" class="headerlink" title="12. lambda表达式"></a>12. lambda表达式</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;*** lambda表达式* option: --decodelambdas false*&#x2F;public void lambdaTest() &#123;    String[] qingshanli &#x3D; &#123;&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&#125;;      List&lt;String&gt; list &#x3D;  Arrays.asList(qingshanli);    &#x2F;&#x2F; 使用lambda表达式以及函数操作    list.forEach((str) -&gt; System.out.print(str + &quot;; &quot;));    &#x2F;&#x2F; 在JDK8中使用双冒号操作符    list.forEach(System.out::println);  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar lambdaTest.class --decodelambdas false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void lambdaTest() &#123;    String[] qingshanli &#x3D; new String[]&#123;&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&#125;;    List&lt;String&gt; list &#x3D; Arrays.asList(qingshanli);    list.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava&#x2F;lang&#x2F;Object;)V, lambda$0(java.lang.String ), (Ljava&#x2F;lang&#x2F;String;)V)());    PrintStream printStream &#x3D; System.out;    printStream.getClass();    list.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava&#x2F;lang&#x2F;Object;)V, println(java.lang.String ), (Ljava&#x2F;lang&#x2F;String;)V)((PrintStream)printStream));&#125;private static &#x2F;* synthetic *&#x2F; void lambda$0(String str) &#123;    System.out.print(String.valueOf(str) + &quot;; &quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 可以看到，在 `forEach` 方法中，其实是调用了 `java.lang.invoke.LambdaMetafactory#metafactory` 方法，该方法的第四个参数 `implMethod` 指定了方法实现。可以看到这里其实是调用了一个 `lambda$0` 方法进行了输出。&gt; - 所以，`lambda` 表达式的实现其实是依赖了一些底层的 API，在编译阶段，编译器会把 `lambda` 表达式进行解糖，转换成调用内部 API 的方式。&gt; - `JDK8` 中新增的双冒号的用法其实和 `lambda` 表达式在底层实现是一样的，就是把方法当做参数传到 `stream` 内部，使 `stream` 的每个元素都传入到该方法里面执行一下。在 `JDK8` 中，接口 `Iterable` 中默认实现了 `forEach` 方法，调用了 `JDK8` 中增加的接口 `Consumer` 内的 `accept` 方法，执行传入的方法参数。</code></pre><hr><h4 id="13-try-with-resources语句"><a href="#13-try-with-resources语句" class="headerlink" title="13. try-with-resources语句"></a>13. try-with-resources语句</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;*** try-with-resources语句* option: --tryresources false*&#x2F;public void tryWithResourcesTest() throws IOException &#123;    try (final StringWriter writer &#x3D; new StringWriter();        final StringWriter writer2 &#x3D; new StringWriter()) &#123;        writer.write(&quot;This is qingshanli1&quot;);        writer2.write(&quot;this is qingshanli2&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar tryWithResourcesTest.class --tryresources false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;* * Enabled force condition propagation * Lifted jumps to return sites *&#x2F;public void tryWithResourcesTest() throws IOException &#123;    Throwable throwable &#x3D; null;    Object var2_3 &#x3D; null;    try &#123;        StringWriter writer &#x3D; new StringWriter();        try &#123;            StringWriter writer2 &#x3D; new StringWriter();            try &#123;                writer.write(&quot;This is qingshanli1&quot;);                writer2.write(&quot;this is qingshanli2&quot;);            &#125;            finally &#123;                if (writer2 !&#x3D; null) &#123;                    writer2.close();                &#125;            &#125;            if (writer &#x3D;&#x3D; null) return;        &#125;        catch (Throwable throwable2) &#123;            if (throwable &#x3D;&#x3D; null) &#123;                throwable &#x3D; throwable2;            &#125; else if (throwable !&#x3D; throwable2) &#123;                throwable.addSuppressed(throwable2);            &#125;            if (writer &#x3D;&#x3D; null) throw throwable;            writer.close();            throw throwable;        &#125;        writer.close();        return;    &#125;    catch (Throwable throwable3) &#123;        if (throwable &#x3D;&#x3D; null) &#123;            throwable &#x3D; throwable3;            throw throwable;        &#125; else &#123;            if (throwable &#x3D;&#x3D; throwable3) throw throwable;            throwable.addSuppressed(throwable3);        &#125;        throw throwable;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 在 `JDK7` 之前, 如 `IO` 流、数据库连接等资源用完后, 都是通过 `finally` 代码块来释放资源。而 `try-with-resources` 语法糖则帮我们省去了释放资源这一操作, 编译器在解语法糖阶段时会将它还原成原始的语法结构。</code></pre><hr><h4 id="14-数字字面量"><a href="#14-数字字面量" class="headerlink" title="14. 数字字面量"></a>14. 数字字面量</h4><pre><code><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;** * literal字面量 * option: *&#x2F;public void literalTest() &#123;    int i &#x3D; 10_000;    System.out.println(i);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- CFR 命令行指令：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">java -jar cfr-0.151.jar literalTest.class<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>- 反编译后的代码<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void literalTest() &#123;    int i &#x3D; 10000;    System.out.println(i);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>- 分析：&gt; - 反编译后就是把 `_` 删除了。也就是说编译器并不认识在数字字面量中的 `_` ，需要在编译阶段把他去掉。</code></pre><hr>]]></content>
    
    
    <summary type="html">对Java语言中的语法糖进行解糖深入剖析</summary>
    
    
    
    <category term="Java" scheme="https://www.onexstone.online/categories/Java/"/>
    
    
    <category term="语法糖" scheme="https://www.onexstone.online/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议之状态码</title>
    <link href="https://www.onexstone.online/posts/d9c27918/"/>
    <id>https://www.onexstone.online/posts/d9c27918/</id>
    <published>2021-09-26T06:16:54.000Z</published>
    <updated>2021-09-26T06:24:35.912Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文是从客户端角度出发，解析服务器端发送而来的状态码的具体含义。</p><span id="more"></span><h3 id="1××-Informational-通知"><a href="#1××-Informational-通知" class="headerlink" title="1×× Informational 通知"></a>1×× Informational 通知</h3><ol><li> 1xx 状态码仅适用于 <strong>HTTP 1.1</strong> 版本及以上。</li></ol><h4 id="100-Continue-继续"><a href="#100-Continue-继续" class="headerlink" title="100 Continue 继续"></a>100 <strong>Continue</strong> 继续</h4><blockquote><ul><li>  请求的初始部分已收到，但尚未被服务器拒绝。服务器打算在请求被完全收到并采取行动后发送最终响应。</li><li>  当请求包含一个包含 <strong>100-continue</strong> 期望的 <strong>Expect</strong> 标头字段时，<strong>100</strong> 响应表示服务器希望收到请求负载正文。客户端应该继续发送请求并丢弃 <strong>100</strong> 响应。</li><li>  如果请求不包含包含 <strong>100-continue</strong> 期望的 <strong>Expect</strong> 标头字段，则客户端可以简单地丢弃此临时响应。</li></ul></blockquote><h4 id="101-Switching-Protocols-切换协议"><a href="#101-Switching-Protocols-切换协议" class="headerlink" title="101 Switching Protocols 切换协议"></a>101 <strong>Switching Protocols</strong> 切换协议</h4><blockquote><ul><li>  服务器了解并愿意通过升级头字段遵守客户端的请求，以更改此连接上正在使用的应用程序协议。</li><li>  服务器必须在响应中生成一个升级头字段，指示在终止 <strong>101</strong> 响应的空行之后将立即切换到哪个协议。</li><li>  注：服务器通常仅在有利时才同意切换协议。例如，切换到较新版本的 <strong>HTTP</strong> 可能比旧版本更有优势，或者切换到实时、同步的协议在交互传输资源时可能更有优势。</li></ul></blockquote><h4 id="102-Processing-处理中"><a href="#102-Processing-处理中" class="headerlink" title="102 Processing 处理中"></a>102 <strong>Processing</strong> 处理中</h4><blockquote><ul><li>  用于通知客户端，服务器已接受完整请求但尚未完成时做出的临时响应。</li><li>  这个状态码应该只在服务器知道请求可能需要很长时间才能完成时发送。假如一个方法需要超过 20 秒（一个合理但任意的值）来处理，服务器就应该返回一个 <strong>102（Processing）</strong> 响应告知客户端该请求目前仍在处理中。服务器必须在请求完成后发送最终响应。</li><li>  方法可能需要很长时间来处理，尤其是支持 <strong>Depth</strong> 标头的方法。在这种情况下，客户端可能会在等待响应时超时连接。为了防止这种情况，服务器可能会返回 <strong>102 Processing</strong> 状态代码以向客户端指示服务器仍在处理该方法。</li></ul></blockquote><hr><h3 id="2××-Success-请求成功返回"><a href="#2××-Success-请求成功返回" class="headerlink" title="2×× Success 请求成功返回"></a>2×× Success 请求成功返回</h3><h4 id="200-OK-成功"><a href="#200-OK-成功" class="headerlink" title="200 OK 成功"></a>200 <strong>OK</strong> 成功</h4><blockquote><ul><li>  请求已成功。</li><li>  200 响应中发送的负载取决于请求方法。对于本规范（<strong>RFC7231</strong>）定义的方法，有效载荷的预期含义可以概括为：</li><li>  <strong>GET</strong> 表示目标资源</li><li>  <strong>HEAD</strong> 与 GET 含义相同，但没有数据</li><li><strong>POST</strong> 表示处理动作的状态或结果；<ul><li>  <strong>PUT DELETE</strong> 表示处理动作状态；</li><li>  <strong>OPTIONS</strong> 表示可选的通信选项；</li><li>  <strong>TRACE</strong> 表示终端服务器收到的请求消息。</li></ul></li><li>  除了对 <strong>CONNECT</strong> 的响应之外，200 响应始终具有有效负载，尽管源服务器可能会生成零长度的有效负载主体。如果不需要有效负载，源服务器应该发送 <strong>204 No Content</strong> 代替。对于 <strong>CONNECT</strong>，不允许有效负载，因为成功的结果是创建一个隧道，该隧道在 200 响应之后立即开始。</li><li>  默认情况下，200 响应是可缓存的；除非方法定义或显式缓存控件另有说明。</li></ul></blockquote><h4 id="201-Created-请求成功，并创建了新的资源"><a href="#201-Created-请求成功，并创建了新的资源" class="headerlink" title="201 Created 请求成功，并创建了新的资源"></a>201 <strong>Created</strong> 请求成功，并创建了新的资源</h4><blockquote><ul><li>  请求已完成并导致创建一个或多个新资源。</li><li>  请求创建的主要资源由响应中的 <strong>Location</strong> 头字段标识，或者，如果没有收到 <strong>Location</strong> 字段，则由有效的请求 URI 标识。</li><li>  201 响应负载通常描述并链接到所创建的资源。</li></ul></blockquote><h4 id="202-Accepted-请求已接受但未处理完成"><a href="#202-Accepted-请求已接受但未处理完成" class="headerlink" title="202 Accepted 请求已接受但未处理完成"></a>202 <strong>Accepted</strong> 请求已接受但未处理完成</h4><blockquote><ul><li>  请求已被接受进行处理，但处理尚未完成。该请求最终可能会或可能不会被执行，因为在实际进行处理时可能会被禁止。</li><li>  <strong>HTTP</strong> 中没有用于从异步操作重新发送状态代码的工具。</li><li>  202 响应的目的是允许服务器接受对某个其他进程（可能是一个每天只运行一次的面向批处理的进程）的请求，而无需用户代理与服务器的连接持续到该进程完成。与此响应一起发送的表示应该描述请求的当前状态并指向（或嵌入）一个状态监视器，该监视器可以为用户提供请求何时完成的估计。</li></ul></blockquote><h4 id="203-Non-authoritative-Information-返回的是非权威（非官方）内容"><a href="#203-Non-authoritative-Information-返回的是非权威（非官方）内容" class="headerlink" title="203 Non-authoritative Information 返回的是非权威（非官方）内容"></a>203 <strong>Non-authoritative Information</strong> 返回的是非权威（非官方）内容</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回 <strong>200 OK</strong> 的情况下才是合适的。</li><li>  简单地说，就是通过代理访问原始服务器的时候，成功获取了原始服务器（状态码 <strong>200</strong>）的返回内容，但代理对内容做出了一些改动，例如修改了文档编码等等，代理通过这个状态码告知客户端，成功获取内容，但这部分内容和原始服务器的返回内容可能不完全一致。</li></ul></blockquote><h4 id="204-No-Content-无内容（请求收到，但返回信息为空）"><a href="#204-No-Content-无内容（请求收到，但返回信息为空）" class="headerlink" title="204 No Content 无内容（请求收到，但返回信息为空）"></a>204 <strong>No Content</strong> 无内容（请求收到，但返回信息为空）</h4><blockquote><ul><li>  服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。</li><li>  如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。</li><li>  由于 <strong>204</strong> 响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</li></ul></blockquote><h4 id="205-Reset-Content-重置视图内容（请求已完成，要求客户端复位视图）"><a href="#205-Reset-Content-重置视图内容（请求已完成，要求客户端复位视图）" class="headerlink" title="205 Reset Content 重置视图内容（请求已完成，要求客户端复位视图）"></a>205 <strong>Reset Content</strong> 重置视图内容（请求已完成，要求客户端复位视图）</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器成功处理了请求，且没有返回任何内容。但是与 <strong>204</strong> 响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。</li><li>  与 <strong>204</strong> 响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</li></ul></blockquote><h4 id="206-Partial-Content-部分处理"><a href="#206-Partial-Content-部分处理" class="headerlink" title="206 Partial Content 部分处理"></a>206 <strong>Partial Content</strong> 部分处理</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  表示该服务器已经成功处理了部分 <strong>GET</strong> 请求。类似于 <strong>FlashGet</strong> 或者迅雷这类的 <strong>HTTP</strong> 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</li><li>  该请求必须包含 <strong>Range</strong> 头信息来指示客户端希望得到的内容范围，并且可能包含 <strong>If-Range</strong> 来作为请求条件。</li><li>响应必须包含如下的头部域：<ul><li>  <strong>Content-Range</strong> 用以指示本次响应中返回的内容的范围；如果是 <strong>Content-Type</strong> 为 <strong>multipart/byteranges</strong> 的多段下载，则每一 <strong>multipart</strong> 段中都应包含 <strong>Content-Range</strong> 域用以指示本段的内容范围。假如响应中包含 <strong>Content-Length</strong>，那么它的数值必须匹配它返回的内容范围的真实字节数</li></ul></li></ul></blockquote><h4 id="207-Multi-Status-多状态响应"><a href="#207-Multi-Status-多状态响应" class="headerlink" title="207 Multi-Status 多状态响应"></a>207 <strong>Multi-Status</strong> 多状态响应</h4><blockquote><ul><li>  由 <strong>WebDAV（RFC2518）</strong> 扩展的状态码，代表之后的消息体将是一个 <strong>XML</strong> 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</li></ul></blockquote><h4 id="208-Already-Reported-已经报告"><a href="#208-Already-Reported-已经报告" class="headerlink" title="208 Already Reported 已经报告"></a>208 <strong>Already Reported</strong> 已经报告</h4><blockquote><ul><li>  一个 <strong>DAV</strong> 的绑定成员被前一个请求枚举，并且没有被再一次包括。</li></ul></blockquote><h4 id="226-IM-Used"><a href="#226-IM-Used" class="headerlink" title="226 IM Used"></a>226 <strong>IM Used</strong></h4><blockquote><ul><li>  服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实例的结果。</li></ul></blockquote><hr><h3 id="3××-Redirection-重定向"><a href="#3××-Redirection-重定向" class="headerlink" title="3×× Redirection 重定向"></a>3×× Redirection 重定向</h3><h4 id="300-Multiple-Choices-多重选择"><a href="#300-Multiple-Choices-多重选择" class="headerlink" title="300 Multiple Choices 多重选择"></a>300 <strong>Multiple Choices</strong> 多重选择</h4><blockquote><ul><li>  客户请求的资源可以在多个位置找到，这些位置已经在返回的载荷内列出。如果服务器要提出优先选择，则应该在 <strong>Location</strong> 应答头指明。</li><li>  除非这是一个 <strong>HEAD</strong> 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 <strong>Content-Type</strong> 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，<strong>RFC 2616</strong> 规范并没有规定这样的自动选择该如何进行。</li><li>  如果服务器本身已经有了首选的回馈选择，那么在 <strong>Location</strong> 中应当指明这个回馈的 <strong>URI</strong>；浏览器可能会将这个 <strong>Location</strong> 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</li></ul></blockquote><h4 id="301-Moved-Permanently-永久移动（永久重定向）"><a href="#301-Moved-Permanently-永久移动（永久重定向）" class="headerlink" title="301 Moved Permanently 永久移动（永久重定向）"></a>301 <strong>Moved Permanently</strong> 永久移动（永久重定向）</h4><blockquote><ul><li>  客户请求的资源在其他地方，新的 <strong>URL</strong> 在 <strong>Location</strong> 头中给出，浏览器应该自动地访问新的 <strong>URL</strong>。</li><li>  除非这是一个 <strong>HEAD</strong> 请求，否则响应的实体中应当包含指向新的 <strong>URI</strong> 的超链接及简短说明。</li><li>  如果这不是一个 <strong>GET</strong> 或者 <strong>HEAD</strong> 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</li><li>  注意：对于某些使用 <strong>HTTP/1.0</strong> 协议的浏览器，当它们发送的 <strong>POST</strong> 请求得到了一个 <strong>301</strong> 响应的话，接下来的重定向请求将会变成 <strong>GET</strong> 方式。</li></ul></blockquote><h4 id="302-Found-临时性重定向"><a href="#302-Found-临时性重定向" class="headerlink" title="302 Found 临时性重定向"></a>302 <strong>Found</strong> 临时性重定向</h4><blockquote><ul><li>  要求客户端执行临时重定向（原始描述短语为 <strong>Moved Temporarily</strong> ）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 <strong>Cache-Control</strong> 或 <strong>Expires</strong> 中进行了指定的情况下，这个响应才是可缓存的。</li><li>  新的临时性的 <strong>URI</strong> 应当在响应的 <strong>Location</strong> 域中返回。除非这是一个 <strong>HEAD</strong> 请求，否则响应的实体中应当包含指向新的 <strong>URI</strong> 的超链接及简短说明。 如果这不是一个 <strong>GET</strong> 或者 <strong>HEAD</strong> 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</li><li>  注意：虽然 <strong>RFC 1945</strong> 和 <strong>RFC 2068</strong> 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 <strong>302</strong> 响应视作为 <strong>303</strong> 响应，并且使用 <strong>GET</strong> 方式访问在 <strong>Location</strong> 中规定的 <strong>URI</strong>，而无视原先请求的方法。因此状态码 <strong>303</strong> 和 <strong>307</strong> 被添加了进来，用以明确服务器期待客户端进行何种反应。</li></ul></blockquote><h4 id="303-See-Other-查看其它（返回新的资源-URI）"><a href="#303-See-Other-查看其它（返回新的资源-URI）" class="headerlink" title="303 See Other 查看其它（返回新的资源 URI）"></a>303 <strong>See Other</strong> 查看其它（返回新的资源 URI）</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  对应当前请求的响应可以在另一个 <strong>URI</strong> 上被找到，而且客户端应当采用 <strong>GET</strong> 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的 <strong>POST</strong> 请求输出重定向到一个新的资源。这个新的 <strong>URI</strong> 不是原始资源的替代引用。同时，<strong>303</strong>响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</li><li>  注意：许多 <strong>HTTP/1.1</strong> 版以前的浏览器不能正确理解 <strong>303</strong> 状态。如果需要考虑与这些浏览器之间的互动， 状态码应该可以胜任，因为大多数的浏览器处理 <strong>302</strong> 响应时的方式恰恰就是上述规范要求客户端处理 <strong>303</strong> 响应时应当做的。</li></ul></blockquote><h4 id="304-Not-Modified-未修改"><a href="#304-Not-Modified-未修改" class="headerlink" title="304 Not Modified 未修改"></a>304 <strong>Not Modified</strong> 未修改</h4><blockquote><ul><li>  客户端有缓冲的资源并发出了一个条件性的请求（一般是提供 <strong>If-Modified-Since</strong> 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</li></ul></blockquote><h4 id="305-Use-Proxy-使用代理"><a href="#305-Use-Proxy-使用代理" class="headerlink" title="305 Use Proxy 使用代理"></a>305 <strong>Use Proxy</strong> 使用代理</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  客户请求的资源应该通过 <strong>Location</strong> 头所指明的代理服务器提取。</li></ul></blockquote><h4 id="305-Switch-Proxy-切换代理"><a href="#305-Switch-Proxy-切换代理" class="headerlink" title="305 Switch Proxy 切换代理"></a><del>305 <strong>Switch Proxy</strong> 切换代理</del></h4><blockquote><ul><li>  在最新版的规范中，306状态码已经不再被使用。</li></ul></blockquote><h4 id="307-Temporary-Redirect-临时跳转"><a href="#307-Temporary-Redirect-临时跳转" class="headerlink" title="307 Temporary Redirect 临时跳转"></a>307 <strong>Temporary Redirect</strong> 临时跳转</h4><blockquote><ul><li>  <strong>HTTP 1.1</strong> 新增了 <strong>307</strong> ，以便更加清除地区分几个状态代码：当出现 <strong>303</strong> 应答时，客户端可以跟随重定向的 <strong>GET</strong> 和 <strong>POST</strong> 请求；如果是 <strong>303</strong> 应答，则客户端只能跟随对 <strong>POST</strong> 请求的重定向；如果是 <strong>307</strong> 应答，则客户端只能跟随对 <strong>GET</strong> 请求的重定向。</li></ul></blockquote><h4 id="308-Permanent-Redirect-永久跳转"><a href="#308-Permanent-Redirect-永久跳转" class="headerlink" title="308 Permanent Redirect 永久跳转"></a>308 <strong>Permanent Redirect</strong> 永久跳转</h4><blockquote><ul><li>  这个请求和以后的请求都应该被另一个 <strong>URI</strong> 地址重新发送。<strong>307、308</strong>和 <strong>302、301</strong> 有相同的表现，但是不允许 <strong>HTTP</strong> 方法改变。例如，请求表单到一个永久转移的资源将会继续顺利地执行。</li></ul></blockquote><hr><h3 id="4××-Client-Error-客户端错误"><a href="#4××-Client-Error-客户端错误" class="headerlink" title="4×× Client Error 客户端错误"></a>4×× Client Error 客户端错误</h3><h4 id="400-Bad-Request-错误请求"><a href="#400-Bad-Request-错误请求" class="headerlink" title="400 Bad Request 错误请求"></a>400 <strong>Bad Request</strong> 错误请求</h4><blockquote><ul><li>  请求出现语法错误。</li></ul></blockquote><h4 id="401-Unauthorized-未授权"><a href="#401-Unauthorized-未授权" class="headerlink" title="401 Unauthorized 未授权"></a>401 <strong>Unauthorized</strong> 未授权</h4><blockquote><ul><li>访问被拒绝，客户试图未经授权访问受密码保护的页面。应答中会包含一个 <strong>WWW-Authenticate</strong> 头，浏览器据此显示用户名字/密码对话框，然后在填写合适的 <strong>Authorization</strong> 头后再次发出请求。<strong>IIS</strong> 定义了许多不同的 <strong>401</strong> 错误，它们指明更为具体的错误原因。这些具体的错误代码在客户端中显示，但不在 <strong>IIS</strong> 日志中显示：<ul><li>  401.1 - 登录失败。</li><li>  401.2 - 服务器配置导致登录失败。</li><li>  401.3 - 由于 <strong>ACL</strong> 对资源的限制而未获得授权。</li><li>  401.4 - 筛选器授权失败。</li><li>  401.5 - <strong>ISAPI/CGI</strong> 应用程序授权失败。</li><li>  401.7 – 访问被 <strong>Web</strong> 服务器上的 <strong>URL</strong> 授权策略拒绝。这个错误代码为 <strong>IIS 6.0</strong> 所专用。</li></ul></li></ul></blockquote><h4 id="402-Payment-Required-需要付款（未使用，保留状态码）"><a href="#402-Payment-Required-需要付款（未使用，保留状态码）" class="headerlink" title="402 Payment Required 需要付款（未使用，保留状态码）"></a>402 <strong>Payment Required</strong> 需要付款（未使用，保留状态码）</h4><blockquote><ul><li>  为以后保留使用。原意是该状态码可被用于一些数字货币或者是微支付，但是目前还没有普及，所以这些代码不经常被使用。</li></ul></blockquote><h4 id="403-Forbidden-禁止访问"><a href="#403-Forbidden-禁止访问" class="headerlink" title="403 Forbidden 禁止访问"></a>403 <strong>Forbidden</strong> 禁止访问</h4><blockquote><ul><li>资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。<strong>IIS</strong> 定义了许多不同的 <strong>403</strong> 错误，它们指明更为具体的错误原因：<ul><li>  403.1 - 执行访问被禁止。</li><li>  403.2 - 读访问被禁止。</li><li>  403.3 - 写访问被禁止。</li><li>  403.4 - 要求 <strong>SSL</strong>。</li><li>  403.5 - 要求 <strong>SSL 128</strong>。</li><li>  403.6 - IP 地址被拒绝。</li><li>  403.7 - 要求客户端证书。</li><li>  403.8 - 站点访问被拒绝。</li><li>  403.9 - 用户数过多。</li><li>  403.10 - 配置无效。</li><li>  403.11 - 密码更改。</li><li>  403.12 - 拒绝访问映射表。</li><li>  403.13 - 客户端证书被吊销。</li><li>  403.14 - 拒绝目录列表。</li><li>  403.15 - 超出客户端访问许可。</li><li>  403.16 - 客户端证书不受信任或无效。</li><li>  403.17 - 客户端证书已过期或尚未生效。</li><li>  403.18 - 在当前的应用程序池中不能执行所请求的 <strong>URL</strong>。这个错误代码为 IIS 6.0 所专用。</li><li>  403.19 - 不能为这个应用程序池中的客户端执行 <strong>CGI</strong>。这个错误代码为 IIS 6.0 所专用。</li><li>  403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</li></ul></li></ul></blockquote><h4 id="404-Not-Found-资源找不到"><a href="#404-Not-Found-资源找不到" class="headerlink" title="404 Not Found 资源找不到"></a>404 <strong>Not Found</strong> 资源找不到</h4><blockquote><ul><li>  无法找到指定位置的资源。</li><li>  没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 <strong>410</strong> 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。</li></ul></blockquote><h4 id="405-Method-Not-Allowed-方法不允许（请求方法错误）"><a href="#405-Method-Not-Allowed-方法不允许（请求方法错误）" class="headerlink" title="405 Method Not Allowed 方法不允许（请求方法错误）"></a>405 <strong>Method Not Allowed</strong> 方法不允许（请求方法错误）</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 <strong>Allow</strong> 头信息用以表示出当前资源能够接受的请求方法的列表。</li><li>  请求方法（<strong>GET、POST、HEAD、Delete、PUT、TRACE等</strong>）对指定的资源不适用，用来访问本页面的 <strong>HTTP</strong> 谓词不被允许（方法不被允许）</li></ul></blockquote><h4 id="406-Not-Acceptable-不可接受"><a href="#406-Not-Acceptable-不可接受" class="headerlink" title="406 Not Acceptable 不可接受"></a>406 <strong>Not Acceptable</strong> 不可接受</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  指定的资源已经找到，但它的 <strong>MIME</strong> 类型和客户在 <strong>Accpet</strong> 头中所指定的不兼容，客户端浏览器不接受所请求页面的 <strong>MIME</strong> 类型。</li></ul></blockquote><h4 id="407-Proxy-Authentication-Required-需要代理认证"><a href="#407-Proxy-Authentication-Required-需要代理认证" class="headerlink" title="407 Proxy Authentication Required 需要代理认证"></a>407 <strong>Proxy Authentication Required</strong> 需要代理认证</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  要求进行代理身份验证，类似于 <strong>401</strong> ，表示客户必须先经过代理服务器的授权。</li></ul></blockquote><h4 id="408-Request-Timeout-请求超时"><a href="#408-Request-Timeout-请求超时" class="headerlink" title="408 Request Timeout 请求超时"></a>408 <strong>Request Timeout</strong> 请求超时</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</li></ul></blockquote><h4 id="409-Conflict-冲突"><a href="#409-Conflict-冲突" class="headerlink" title="409 Conflict 冲突"></a>409 <strong>Conflict</strong> 冲突</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  通常和 <strong>PUT</strong> 请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。</li></ul></blockquote><h4 id="410-Gone-资源丢失"><a href="#410-Gone-资源丢失" class="headerlink" title="410 Gone 资源丢失"></a>410 <strong>Gone</strong> 资源丢失</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  所请求的资源档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和 <strong>404</strong> 的不同在于，返回 <strong>407</strong> 表示资源永久地离开了指定的位置，而 <strong>404</strong> 表示由于未知的原因资源不可用。</li></ul></blockquote><h4 id="411-Length-Required-长度要求"><a href="#411-Length-Required-长度要求" class="headerlink" title="411 Length Required 长度要求"></a>411 <strong>Length Required</strong> 长度要求</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器不能处理请求，除非客户发送一个 <strong>Content-Length</strong> 头。</li></ul></blockquote><h4 id="412-Precondition-Failed-前置条件错误"><a href="#412-Precondition-Failed-前置条件错误" class="headerlink" title="412 Precondition Failed 前置条件错误"></a>412 <strong>Precondition Failed</strong> 前置条件错误</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  请求头中指定的一些前提条件失败。</li><li>  这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</li></ul></blockquote><h4 id="413-Payload-Too-Large-响应实体太长"><a href="#413-Payload-Too-Large-响应实体太长" class="headerlink" title="413 Payload Too Large 响应实体太长"></a>413 <strong>Payload Too Large</strong> 响应实体太长</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</li><li>  如果这个状况是临时的，服务器应当返回一个 <strong>Retry-After</strong> 的响应头，以告知客户端可以在多少时间以后重新尝试</li></ul></blockquote><h4 id="414-Request-URI-Too-Long-请求-URI-太长"><a href="#414-Request-URI-Too-Long-请求-URI-太长" class="headerlink" title="414 Request-URI Too Long 请求 URI 太长"></a>414 <strong>Request-URI Too Long</strong> 请求 URI 太长</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  客户端提供的URI对服务器的处理来说太长。经常出现在太多被编码的数据被作为查询字符串的 <strong>GET</strong> 请求的结果，因此需要被转换为 <strong>POST</strong> 请求。</li></ul></blockquote><h4 id="415-Unsupported-Media-Type-不支持的媒体类型"><a href="#415-Unsupported-Media-Type-不支持的媒体类型" class="headerlink" title="415 Unsupported Media Type 不支持的媒体类型"></a>415 <strong>Unsupported Media Type</strong> 不支持的媒体类型</h4><blockquote><ul><li>  请求实体的媒体类型不被服务器或者资源支持。例如，客户端上传一个 <strong>image/svg+xml</strong> 的图片，但是服务器需要图片使用不同的格式。</li></ul></blockquote><h4 id="416-Requested-Range-Not-Satisfiable-请求范围不能满足"><a href="#416-Requested-Range-Not-Satisfiable-请求范围不能满足" class="headerlink" title="416 Requested Range Not Satisfiable 请求范围不能满足"></a>416 <strong>Requested Range Not Satisfiable</strong> 请求范围不能满足</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器不能满足客户在请求中指定的 <strong>Range</strong> 头。</li></ul></blockquote><h4 id="417-Expectation-Failed-执行失败"><a href="#417-Expectation-Failed-执行失败" class="headerlink" title="417 Expectation Failed 执行失败"></a>417 <strong>Expectation Failed</strong> 执行失败</h4><blockquote><ul><li>  在请求头 <strong>Expect</strong> 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，<strong>Expect</strong> 的内容无法被满足。</li></ul></blockquote><h4 id="418-I’m-a-teapot-我是茶壶"><a href="#418-I’m-a-teapot-我是茶壶" class="headerlink" title="418 I’m a teapot 我是茶壶"></a>418 <strong>I’m a teapot</strong> <del>我是茶壶</del></h4><blockquote><ul><li>  这个代码是在 1998 年作为传统的 <strong>IETF April Fools‘ jokes</strong> 被定义的在 <strong>RFC2324</strong>，超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现。RFC指定了这个代码应该是由茶罐返回给速溶咖啡。</li></ul></blockquote><h4 id="421-Misdirected-Request-误导请求"><a href="#421-Misdirected-Request-误导请求" class="headerlink" title="421 Misdirected Request 误导请求"></a>421 <strong>Misdirected Request</strong> 误导请求</h4><blockquote><ul><li>  请求被直接定向到不能产生响应的服务器上（例如因为一个连接的复用）。</li></ul></blockquote><h4 id="422-Unprocessable-Entity-不可处理的实体"><a href="#422-Unprocessable-Entity-不可处理的实体" class="headerlink" title="422 Unprocessable Entity 不可处理的实体"></a>422 <strong>Unprocessable Entity</strong> 不可处理的实体</h4><blockquote><ul><li>  请求格式正确，但是由于含有语义错误，无法响应。</li></ul></blockquote><h4 id="423-Locked-锁定"><a href="#423-Locked-锁定" class="headerlink" title="423 Locked 锁定"></a>423 <strong>Locked</strong> 锁定</h4><blockquote><ul><li>  当前资源被锁定。</li></ul></blockquote><h4 id="424-Failed-Dependency-失败的依赖"><a href="#424-Failed-Dependency-失败的依赖" class="headerlink" title="424 Failed Dependency 失败的依赖"></a>424 <strong>Failed Dependency</strong> 失败的依赖</h4><blockquote><ul><li>  由于之前的某个请求发生的错误，导致当前请求失败，例如 <strong>PROPPATCH</strong>。</li></ul></blockquote><h4 id="426-Upgrade-Required-需要升级"><a href="#426-Upgrade-Required-需要升级" class="headerlink" title="426 Upgrade Required 需要升级"></a>426 <strong>Upgrade Required</strong> 需要升级</h4><blockquote><ul><li>  客户端应该切换不同的协议，例如 <strong>TLS/1.0</strong> （RFC 2817）。</li></ul></blockquote><h4 id="428-Precondition-Required-需要前置条件"><a href="#428-Precondition-Required-需要前置条件" class="headerlink" title="428 Precondition Required 需要前置条件"></a>428 <strong>Precondition Required</strong> 需要前置条件</h4><blockquote><ul><li>  原始服务器需要有条件的请求。当客户端 <strong>GET</strong> 一个资源的状态的时候，同时又 <strong>PUT</strong> 回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。</li></ul></blockquote><h4 id="429-Too-Many-Requests-过多请求"><a href="#429-Too-Many-Requests-过多请求" class="headerlink" title="429 Too Many Requests 过多请求"></a>429 <strong>Too Many Requests</strong> 过多请求</h4><blockquote><ul><li>  用户已经发送了太多的请求在指定的时间里。用于限制速率。</li></ul></blockquote><h4 id="431-Request-Header-Fields-Too-Large-请求头部字段太大"><a href="#431-Request-Header-Fields-Too-Large-请求头部字段太大" class="headerlink" title="431 Request Header Fields Too Large 请求头部字段太大"></a>431 <strong>Request Header Fields Too Large</strong> 请求头部字段太大</h4><blockquote><ul><li>  服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。</li></ul></blockquote><h4 id="444-Connection-Closed-Without-Response-无响应，连接关闭"><a href="#444-Connection-Closed-Without-Response-无响应，连接关闭" class="headerlink" title="444 Connection Closed Without Response 无响应，连接关闭"></a>444 <strong>Connection Closed Without Response</strong> 无响应，连接关闭</h4><blockquote><ul><li>  被使用在 <strong>Nginx</strong> 的日志中，表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。</li></ul></blockquote><h4 id="451-Unavailable-For-Legal-Reasons-由于法律原因而无效（因特网草稿）"><a href="#451-Unavailable-For-Legal-Reasons-由于法律原因而无效（因特网草稿）" class="headerlink" title="451 Unavailable For Legal Reasons 由于法律原因而无效（因特网草稿）"></a>451 <strong>Unavailable For Legal Reasons</strong> 由于法律原因而无效（因特网草稿）</h4><blockquote><ul><li>  被定义在因特网草稿 “一个新的HTTP状态码用于法律限制的资源” 。被用于当资源的访问由于法律原因被禁止的时候。</li></ul></blockquote><h4 id="499-Client-Closed-Request-关闭连接"><a href="#499-Client-Closed-Request-关闭连接" class="headerlink" title="499 Client Closed Request 关闭连接"></a>499 <strong>Client Closed Request</strong> 关闭连接</h4><blockquote><ul><li>  <strong>nginx</strong> 引入的非标准状态码，用于客户端在 nginx 处理请求时关闭连接的情况。</li></ul></blockquote><hr><h3 id="5××-Server-Error-服务器错误"><a href="#5××-Server-Error-服务器错误" class="headerlink" title="5×× Server Error 服务器错误"></a>5×× Server Error 服务器错误</h3><h4 id="500-Internal-Server-Error-服务器内部错误"><a href="#500-Internal-Server-Error-服务器内部错误" class="headerlink" title="500 Internal Server Error 服务器内部错误"></a>500 <strong>Internal Server Error</strong> 服务器内部错误</h4><blockquote><ul><li>服务器遇到了意料不到的情况，不能完成客户的请求。一般来说，这个问题都会在服务器端的源代码出现错误时出现。<ul><li>  500.12 - 应用程序正忙于在 <strong>Web</strong> 服务器上重新启动。</li><li>  500.13 - <strong>Web</strong> 服务器太忙。</li><li>  500.15 - 不允许直接请求 <strong>Global.asa</strong>。</li><li>  500.16 – <strong>UNC</strong> 授权凭据不正确。这个错误代码为 <strong>IIS 6.0</strong> 所专用。</li><li>  500.18 – <strong>URL</strong> 授权存储不能打开。这个错误代码为 <strong>IIS 6.0</strong> 所专用。</li><li>  500.100 - 内部 <strong>ASP</strong> 错误。</li></ul></li></ul></blockquote><h4 id="501-Not-Implemented-没有实现"><a href="#501-Not-Implemented-没有实现" class="headerlink" title="501 Not Implemented 没有实现"></a>501 <strong>Not Implemented</strong> 没有实现</h4><blockquote><ul><li>  服务器不支持实现请求所需要的功能，页眉值指定了未实现的配置。例如，客户发出了一个服务器不支持的 <strong>PUT</strong> 请求。</li><li>  解决 <strong>501</strong> 错误一般方法，这个错误在任何浏览器上都应是非常罕见的。 如果客户端不是一个浏览器则更有可能 – 特别是如果 <strong>Web</strong> 服务器很旧时。 在这两种情况下， 如果客户端指定了一个有效的请求类型， 那么 <strong>Web</strong> 服务器不是响应不正确，就是需要升级。</li></ul></blockquote><h4 id="502-Bad-Gateway-网关错误"><a href="#502-Bad-Gateway-网关错误" class="headerlink" title="502 Bad Gateway 网关错误"></a>502 <strong>Bad Gateway</strong> 网关错误</h4><blockquote><ul><li>服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 亦说 <strong>Web</strong> 服务器用作网关或代理服务器时收到了无效响应。<ul><li>  502.1 - CGI 应用程序超时。</li><li>  502.2 - CGI 应用程序出错。</li></ul></li></ul></blockquote><h4 id="503-Service-Unavailable-服务不可用"><a href="#503-Service-Unavailable-服务不可用" class="headerlink" title="503 Service Unavailable 服务不可用"></a>503 <strong>Service Unavailable</strong> 服务不可用</h4><blockquote><ul><li>  服务器由于维护或者负载过重未能应答。</li><li>  例如，<strong>Servlet</strong> 可能在数据库连接池已满的情况下返回 <strong>503</strong> 。服务器返回 <strong>503</strong> 时可以提供一个 <strong>Retry-After</strong> 头。这个错误代码为 <strong>IIS 6.0</strong> 所专用。</li></ul></blockquote><h4 id="504-Gateway-Timeout-网关超时"><a href="#504-Gateway-Timeout-网关超时" class="headerlink" title="504 Gateway Timeout 网关超时"></a>504 <strong>Gateway Timeout</strong> 网关超时</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。</li></ul></blockquote><h4 id="505-HTTP-Version-Not-Supported-HTTP-版本不支持"><a href="#505-HTTP-Version-Not-Supported-HTTP-版本不支持" class="headerlink" title="505 HTTP Version Not Supported HTTP 版本不支持"></a>505 <strong>HTTP Version Not Supported</strong> HTTP 版本不支持</h4><blockquote><ul><li>  HTTP 1.1中新加入的状态码。</li><li>  服务器不支持请求中所指明的 <strong>HTTP</strong> 版本。</li></ul></blockquote><h4 id="506-Variant-Also-Negotiates-变量也是导航"><a href="#506-Variant-Also-Negotiates-变量也是导航" class="headerlink" title="506 Variant Also Negotiates 变量也是导航"></a>506 <strong>Variant Also Negotiates</strong> 变量也是导航</h4><blockquote><ul><li>  对于请求是透明的内容导航导致循环参照。</li></ul></blockquote><h4 id="507-Insufficient-Storage-存储不足"><a href="#507-Insufficient-Storage-存储不足" class="headerlink" title="507 Insufficient Storage 存储不足"></a>507 <strong>Insufficient Storage</strong> 存储不足</h4><blockquote><ul><li>  服务器不能存储需要的内容去完成请求。</li></ul></blockquote><h4 id="508-Loop-Detected-返现环路"><a href="#508-Loop-Detected-返现环路" class="headerlink" title="508 Loop Detected 返现环路"></a>508 <strong>Loop Detected</strong> 返现环路</h4><blockquote><ul><li>  服务器发现了一个无限的循环档处理请求的时候。</li></ul></blockquote><h4 id="510-Not-Extended-未扩展"><a href="#510-Not-Extended-未扩展" class="headerlink" title="510 Not Extended 未扩展"></a>510 <strong>Not Extended</strong> 未扩展</h4><blockquote><ul><li>  请求中未满足访问资源的策略。服务器应该发回客户端发出扩展请求所需的所有信息。</li></ul></blockquote><h4 id="511-Network-Authentication-Required-需要网络授权"><a href="#511-Network-Authentication-Required-需要网络授权" class="headerlink" title="511 Network Authentication Required 需要网络授权"></a>511 <strong>Network Authentication Required</strong> 需要网络授权</h4><blockquote><ul><li>  客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。</li></ul></blockquote><h4 id="599-Network-Connect-Timeout-Error-网络连接超时异常-未知"><a href="#599-Network-Connect-Timeout-Error-网络连接超时异常-未知" class="headerlink" title="599 Network Connect Timeout Error 网络连接超时异常(未知)"></a>599 <strong>Network Connect Timeout Error</strong> 网络连接超时异常(未知)</h4><blockquote><ul><li>  这个状态码也没有在任何RFC中指定，但被某些 HTTP 代理用于向代理前面的客户端发送代理后面的网络连接超时信号。</li></ul></blockquote><hr><p>参考文献</p><ol><li> <a href="https://datatracker.ietf.org/doc/html/rfc7230">RCF7230</a></li><li> <a href="https://datatracker.ietf.org/doc/html/rfc7231">RCF7231</a></li><li> <a href="https://datatracker.ietf.org/doc/html/rfc7232">RCF7232</a></li></ol><hr>]]></content>
    
    
    <summary type="html">HTTP协议的状态码解释</summary>
    
    
    
    <category term="网络协议" scheme="https://www.onexstone.online/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="HTTP" scheme="https://www.onexstone.online/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.onexstone.online/posts/4a17b156/"/>
    <id>https://www.onexstone.online/posts/4a17b156/</id>
    <published>2021-09-26T01:02:21.941Z</published>
    <updated>2021-09-26T05:45:01.322Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深入剖析volatile关键字</title>
    <link href="https://www.onexstone.online/posts/369cb3ec/"/>
    <id>https://www.onexstone.online/posts/369cb3ec/</id>
    <published>2021-09-25T09:29:28.000Z</published>
    <updated>2021-10-02T09:57:44.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><blockquote><p>关键字 volatile 可以说是 Java 提供的最轻量级的同步机制，但由于它并不容易被正确、完整地理解，因此在笔者查阅了相关资料后，觉得有必要深入剖析一下在 JVM 层面上，对 volatile 型变量都做了哪些支持。</p></blockquote><span id="more"></span><h3 id="2-测试环境"><a href="#2-测试环境" class="headerlink" title="2. 测试环境"></a>2. 测试环境</h3><pre><code>- JDK：    - java version &quot;1.8.0_202&quot;    - Java(TM) SE Runtime Environment (build 1.8.0_202-b08)    - Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)- OS：Windows 10- IDE：    - IntelliJ IDEA 2021.1.3 (Ultimate Edition)    - Eclipse IDE , Version: Oxygen.3a Release (4.7.3a)- HSDIS plug-in :    - [Windows Version](https://github.com/doexit/hsdis.dll)</code></pre><hr><h3 id="3-volatile-的定义"><a href="#3-volatile-的定义" class="headerlink" title="3. volatile 的定义"></a>3. volatile 的定义</h3><ul><li>Java 语言规范（第三版）中对 volatile 的定义如下：<blockquote><p>Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致性的更新，线程应该确保通过排他锁单独获得这个变量。</p></blockquote></li></ul><hr><h3 id="4-volatile-型变量的特性"><a href="#4-volatile-型变量的特性" class="headerlink" title="4. volatile 型变量的特性"></a>4. volatile 型变量的特性</h3><ul><li>JMM （Java Memory Model, Java 内存模型）中对 volatile 变量定义的特殊规则：<ul><li>要求在工作内存中，每次使用 volatile 变量之前都必须先从主内存刷新最新的值，用于保证能看到其他线程对 volatile 变量所做的修改。</li><li>要求在工作内存中，每次修改 volatile 变量后都必须立刻同步回主内存，用于保证其他线程可以看到自己对 volatile 变量所做的修改。</li><li>要求被 volatile 修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。</li></ul></li><li>因此，当一个变量被定义成 volatile 之后，它将具有以下两个特性：<ul><li>保证此变量对所有线程的可见性；</li><li>禁止指令重排序优化（尤其指变量赋值操作的顺序）</li></ul></li></ul><hr><h3 id="5-语义解释"><a href="#5-语义解释" class="headerlink" title="5. 语义解释"></a>5. 语义解释</h3><ul><li><p>线程的可见性：</p><blockquote><p>一般指当一条线程修改了这个变量的值，新值对其他线程来说是可以立即得知的。</p></blockquote></li><li><p>JVM 中对该语义的支持</p><ul><li><p>使用双锁检测（DCL）实现的单例模式进行讲解，Java 源代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Singleton &#123;    private volatile static Singleton instance;    public static Singleton getInstance() &#123;        if (instance &#x3D;&#x3D; null) &#123;            synchronized (Singleton.class) &#123;                if (instance &#x3D;&#x3D; null) &#123;                    instance &#x3D; new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;    public static void main(String[] args) &#123;        Singleton.getInstance();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>其中，对 instance 变量赋值的部分转成汇编代码（此处使用的是 HSDIS 插件，该插件的作用是让 HostSpot 的 -XX:PrintAssembly 指令调用它来把即时编译器动态生成的本地代码还原成汇编代码输出），如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">0x00000000032061dc: movabs $0xd5ec0c38,%rax   ;   &#123;oop(a &#39;java&#x2F;lang&#x2F;Class&#39; &#x3D; &#39;com&#x2F;xxx&#x2F;JVMTest&#x2F;Singleton&#39;)&#125;0x00000000032061e6: mov    0x20(%rsp),%rsi0x00000000032061eb: mov    %rsi,%r100x00000000032061ee: mov    %r10d,0x68(%rax)0x00000000032061f2: shr    $0x9,%rax0x00000000032061f6: movabs $0x120b4000,%rsi0x0000000003206200: movb   $0x0,(%rax,%rsi,1)0x0000000003206204: lock addl $0x0,(%rsp)     ;*putstatic instance                                            ; - com.xxx.JVMTest.Singleton::getInstance@24 (line 17)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>通过对比 volatile 添加前后的汇编代码可以发现，有 volatile 变量修饰的共享变量进行写操作的时候会多执行一个 “lock addl $0x0,(%rsp)” 操作，这个操作的作用相当于一个内存屏障。</p></li><li><p>通过查询 IA32 手册可知，lock 前缀的指令在多核处理器下会引发两件事情：</p><ul><li>将当前处理器缓存行的数据写回到系统内存；</li><li>该写入动作会使其他处理器或者内核中缓存了该内存地址的数据无效化。</li></ul></li><li><p>因此，通过这样一个空操作（addl $0x0,(%rsp)，把RSP寄存器的值加0），就可以让前面 volatile 变量的修改对其他处理器立即可见。同时，因为 lock 指令的本质是对 volatile 变量立即进行 “store” 和 “write” 操作，即该指令依赖于之前对 volatile 变量的其他操作，进而使得处理器不会对 lock 指令进行重排序到 volatile 其他指令之前，也就达到了“指令重排序无法越过内存屏障”的效果。</p></li></ul><hr><h3 id="6-理解误区"><a href="#6-理解误区" class="headerlink" title="6. 理解误区"></a>6. 理解误区</h3><ul><li><p><strong>基于 volatile 变量的运算在并发下是线程安全的。 (×)</strong></p></li><li><p>下面，笔者用一个 volatile 变量自增的例子来说明这个问题</p>  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class VolatileTest &#123;    public static volatile int count &#x3D; 0;    public static void increase() &#123;        count++;    &#125;    private static final int THREADS_COUNT &#x3D; 20;    public static void main(String[] args) &#123;        Thread[] threads &#x3D; new Thread[THREADS_COUNT];        for (int i &#x3D; 0; i &lt; THREADS_COUNT; i++) &#123;            threads[i] &#x3D; new Thread(new Runnable() &#123;                @Override                public void run() &#123;                    for (int i &#x3D; 0; i &lt; 100; i++) &#123;                        increase();                    &#125;                &#125;            &#125;);            threads[i].start();        &#125;        &#x2F;&#x2F; 等待所有累加线程都结束        while (Thread.activeCount() &gt; 1) &#123;            Thread.yield();        &#125;        System.out.println(count);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行演示<br><img src="https://oscimg.oschina.net/oscnet/up-847fae85f848d492abb003083a403ac0556.gif" alt="VolatileTest执行演示" loading="lazy"><em>VolatileTest执行演示</em></p></li><li><p>这段代码的作用是建立了 20 个线程，每个线程对 count 变量进行 100 次自增操作。理论上，在所有线程并发正确的情况下，最后输出的结果应该是 2000 。但通过多次的实际运行可以发现，每次输出的结果都不一样，甚至是一个小于 2000 的数字。</p></li><li><p>使用 javap 命令对 VolatileTest 进行反编译的代码如下：</p>  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void increase();    Code:    0: getstatic     #2                  &#x2F;&#x2F; Field count:I    3: iconst_1    4: iadd    5: putstatic     #2                  &#x2F;&#x2F; Field count:I    8: return    LineNumberTable:    line 15: 0    line 16: 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从字节码层面我们可以很容易的发现问题的所在，当 getstatic 指令把 count 的值取到操作栈顶时， volatile 关键字保证了 count 的值在此时是正确的，但在执行 iconst_1 、iadd 这些指令（非原子操作）的时候，其他线程可能已经把 count 的值改变了，而操作栈顶的值就变成了过期的数据，所以 putstatic 指令执行后就可能把较小的 count 值同步回主内存中。</p></li></ul><hr><h3 id="7-使用场景"><a href="#7-使用场景" class="headerlink" title="7. 使用场景"></a>7. 使用场景</h3><ul><li>通过上面的例子我们应该清楚，由于 volatile 变量只保证可见性，在不符合以下两条规则的运算场景中，我们依然需要通过加锁（使用 synchronized、java.util.concurrent 中的锁或原子类）来保证原子性：<ul><li>运算结果并不依赖变量的当前值（无后效性），或者能够确保只有单一的线程修改变量的值；</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul></li></ul><hr><h3 id="8-参考文献"><a href="#8-参考文献" class="headerlink" title="8. 参考文献"></a>8. 参考文献</h3><pre><code>1. 方腾飞, 魏鹏, 程晓明．Java并发编程的艺术 [M]. 北京：机械工业出版社，2015：8-11.2. 周志明．深入理解Java虚拟机: JVM高级特性与最佳实践（3 版）[M]. 北京：机械工业出版社，2019：444-450.</code></pre>]]></content>
    
    
    <summary type="html">Java 并发底层原理的支持</summary>
    
    
    
    <category term="Java" scheme="https://www.onexstone.online/categories/Java/"/>
    
    <category term="Java并发编程" scheme="https://www.onexstone.online/categories/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JVM" scheme="https://www.onexstone.online/tags/JVM/"/>
    
    <category term="Java" scheme="https://www.onexstone.online/tags/Java/"/>
    
  </entry>
  
</feed>
